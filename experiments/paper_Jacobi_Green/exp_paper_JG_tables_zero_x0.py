import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
from scipy.constants import precision

# plot geometries
from muFFTTO import domain
from muFFTTO import solvers
from muFFTTO import microstructure_library


def scale_field(field, min_val, max_val):
    """Scales a 2D random field to be within [min_val, max_val]."""
    field_min, field_max = field.min(), field.max()
    scaled_field = (field - field_min) / (field_max - field_min)  # Normalize to [0,1]
    return scaled_field * (max_val - min_val) + min_val  # Scale to [min_val, max_val]


problem_type = 'elasticity'
discretization_type = 'finite_element'
element_type = 'linear_triangles'
formulation = 'small_strain'

domain_size = [1, 1]

src = './figures/'
# Enable LaTeX rendering
plt.rcParams.update({
    "text.usetex": True,  # Use LaTeX
    # "font.family": "helvetica",  # Use a serif font
})
plt.rcParams.update({'font.size': 11})
plt.rcParams["font.family"] = "Arial"

#
# nb_it_semi_continuous_16 = np.array([20., 32., 31., 30., 29., 28.])
# nb_it_Jacobi_semi_continuous_16 = np.array([16., 47., 86., 167., 310., 588.])
# nb_it_combi_semi_continuous_16 = np.array([5., 8., 12., 20., 35., 64.])
#
# nb_it_continuous = np.array([20., 53., 87., 84., 52., 20.])
# nb_it_Jacobi_continuous = np.array([16., 46., 88., 166., 310., 585.])
# nb_it_combi_continuous = np.array([5., 3., 3., 3., 3., 2.])
#
# Nx = np.array([1, 4, 8, 16, 32, 64]) * 16
#
# fig = plt.figure()
# gs = fig.add_gridspec(1, 1)
# ax = fig.add_subplot(gs[0, 0])
# # Plot each line with a different z offset
# # for i in np.arange(len(nb_pix_multips)):
# ax.plot(Nx, nb_it_semi_continuous_16, label='PCG: Green', color='blue')
# ax.plot(Nx, nb_it_Jacobi_semi_continuous_16, label='PCG: Jacobi', color='black')
# ax.plot(Nx, nb_it_combi_semi_continuous_16, label='PCG: Green + Jacobi', color='red')
# ax.plot(Nx, nb_it_continuous, label='continuous PCG: Green', color='blue', linestyle='--')
# ax.plot(Nx, nb_it_Jacobi_continuous, label='continuous PCG: Jacobi', color='black', linestyle='--')
# ax.plot(Nx, nb_it_combi_continuous, label='continuous PCG: Green + Jacobi', color='red', linestyle='--')
#
# ax.set_xlabel('Grid size')
# ax.set_ylabel(r'\# PCG iterations')
# # plt.legend(['PCG: Green', 'PCG: Jacobi', 'PCG: Green + Jacobi', 'Richardson Green', 'Richardson Green+Jacobi'])
# plt.legend()
#
# fname = src + 'JG_exp4_GRID_DEP_comparison_{}{}'.format(0, '.pdf')
# print(('create figure: {}'.format(fname)))
# plt.savefig(fname, bbox_inches='tight')
#
# plt.show()

#### numbers of iterations
#### sine_wave_ geometry

# nb_pix_multips =              [2, 3,     4, 5, 6, 7, 8, 9  ]
nb_it_Green_4 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                          [8., 10., 0., 0., 0., 0., 0., 0., 0.],
                          [9., 14., 19., 0., 0., 0., 0., 0., 0.],
                          [11., 17., 25., 30., 0., 0., 0., 0., 0.],
                          [11., 17., 28., 43., 48., 0., 0., 0., 0.],
                          [11., 17., 30., 45., 67., 62., 0., 0., 0.],
                          [11., 19., 30., 49., 68., 76., 67., 0., 0.],
                          [11., 20., 31., 50., 69., 78., 68., 68., 0.],
                          [11., 20., 32., 51., 72., 79., 69., 69., 69.]])

nb_it_Green_1 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                          [7., 8., 0., 0., 0., 0., 0., 0., 0.],
                          [8., 10., 10., 0., 0., 0., 0., 0., 0.],
                          [8., 10., 10., 10., 0., 0., 0., 0., 0.],
                          [9., 10., 10., 10., 10., 0., 0., 0., 0.],
                          [10., 10., 10., 10., 10., 10., 0., 0., 0.],
                          [10., 10., 10., 10., 10., 10., 10., 0., 0.],
                          [10., 10., 10., 10., 10., 10., 10., 10., 0.],
                          [10., 10., 10., 10., 10., 10., 10., 10., 10.]])

#### sine_wave_ geometry with zero insterad of smallest phase
nb_it_Green_1_0 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                            [7., 8., 0., 0., 0., 0., 0., 0., 0.],
                            [8., 10., 10., 0., 0., 0., 0., 0., 0.],
                            [8., 10., 10., 10., 0., 0., 0., 0., 0.],
                            [9., 10., 10., 10., 10., 0., 0., 0., 0.],
                            [10., 10., 10., 10., 10., 10., 0., 0., 0.],
                            [10., 10., 10., 10., 10., 10., 10., 0., 0.],
                            [10., 10., 10., 10., 10., 10., 10., 10., 0.],
                            [10., 10., 10., 10., 10., 10., 10., 10., 10.]])

nb_it_Green_4_0 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                            [8., 10., 0., 0., 0., 0., 0., 0., 0.],
                            [9., 14., 19., 0., 0., 0., 0., 0., 0.],
                            [11., 17., 25., 30., 0., 0., 0., 0., 0.],
                            [11., 17., 28., 43., 48., 0., 0., 0., 0.],
                            [11., 17., 30., 45., 67., 62., 0., 0., 0.],
                            [11., 19., 30., 49., 68., 76., 67., 0., 0.],
                            [11., 20., 31., 50., 69., 78., 68., 68., 0.],
                            [11., 20., 32., 51., 72., 79., 69., 69., 69.]])

#### sine_wave_ geometry with zero insterad of smallest phase and inverted geoemtry
nb_it_Green_4_0_inv = np.array(
    [[5., 0., 0., 0., 0., 0., 0., 0.],
     [8., 11., 0., 0., 0., 0., 0., 0.],
     [10., 16., 20., 0., 0., 0., 0., 0.],
     [11., 18., 27., 35., 0., 0., 0., 0.],
     [11., 17., 32., 47., 54., 0., 0., 0.],
     [11., 17., 31., 48., 76., 89., 0., 0.],
     [11., 19., 30., 49., 72., 97., 100., 0.],
     [11., 19., 29., 49., 68., 88., 73., 53.]])

#### sine_wave_ geometry with zero insterad of smallest phase and inverted geoemtry
nb_it_combi_4 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                          [5., 5., 0., 0., 0., 0., 0., 0., 0.],
                          [8., 6., 4., 0., 0., 0., 0., 0., 0.],
                          [10., 9., 5., 4., 0., 0., 0., 0., 0.],
                          [15., 11., 9., 5., 4., 0., 0., 0., 0.],
                          [25., 19., 13., 8., 5., 4., 0., 0., 0.],
                          [47., 33., 20., 13., 8., 4., 4., 0., 0.],
                          [87., 58., 37., 21., 13., 7., 4., 4., 0.],
                          [176., 106., 72., 36., 20., 13., 7., 4., 4.]])

nb_it_combi_1 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                          [5., 4., 0., 0., 0., 0., 0., 0., 0.],
                          [6., 5., 4., 0., 0., 0., 0., 0., 0.],
                          [7., 6., 5., 4., 0., 0., 0., 0., 0.],
                          [9., 7., 5., 4., 4., 0., 0., 0., 0.],
                          [11., 8., 6., 5., 4., 4., 0., 0., 0.],
                          [16., 10., 8., 6., 5., 4., 4., 0., 0.],
                          [27., 14., 10., 7., 6., 5., 4., 4., 0.],
                          [49., 21., 13., 9., 7., 6., 5., 4., 4.]])

nb_it_combi_1_0 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                            [5., 4., 0., 0., 0., 0., 0., 0., 0.],
                            [6., 5., 4., 0., 0., 0., 0., 0., 0.],
                            [7., 6., 5., 4., 0., 0., 0., 0., 0.],
                            [9., 7., 5., 4., 4., 0., 0., 0., 0.],
                            [11., 8., 6., 5., 4., 4., 0., 0., 0.],
                            [16., 10., 8., 6., 5., 4., 4., 0., 0.],
                            [27., 14., 10., 7., 6., 5., 4., 4., 0.],
                            [49., 21., 13., 9., 7., 6., 5., 4., 4.]])

nb_it_combi_4_0 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                            [5., 5., 0., 0., 0., 0., 0., 0., 0.],
                            [8., 6., 4., 0., 0., 0., 0., 0., 0.],
                            [10., 9., 5., 4., 0., 0., 0., 0., 0.],
                            [15., 11., 9., 5., 4., 0., 0., 0., 0.],
                            [25., 19., 13., 8., 5., 4., 0., 0., 0.],
                            [47., 33., 20., 13., 8., 4., 4., 0., 0.],
                            [87., 58., 37., 21., 13., 7., 4., 4., 0.],
                            [176., 106., 72., 36., 20., 13., 7., 4., 4.]])

nb_it_combi_4_0_inv = np.array([[5., 0., 0., 0., 0., 0., 0., 0.],
                                [6., 5., 0., 0., 0., 0., 0., 0.],
                                [7., 6., 5., 0., 0., 0., 0., 0.],
                                [8., 7., 5., 4., 0., 0., 0., 0.],
                                [9., 8., 7., 5., 3., 0., 0., 0.],
                                [11., 11., 9., 8., 5., 3., 0., 0.],
                                [14., 16., 14., 10., 8., 4., 3., 0.],
                                [22., 24., 20., 16., 10., 8., 4., 3.]])

#### JACOBIIII sine_wave_ geometry with zero insterad of smallest phase and inverted geoemtry
nb_it_Jacobi_4 = np.array([[5., 0., 0., 0., 0., 0., 0., 0.],
                           [11., 10., 0., 0., 0., 0., 0., 0.],
                           [20., 17., 16., 0., 0., 0., 0., 0.],
                           [32., 25., 25., 24., 0., 0., 0., 0.],
                           [62., 47., 47., 46., 46., 0., 0., 0.],
                           [117., 89., 86., 89., 88., 88., 0., 0.],
                           [220., 171., 167., 165., 166., 165., 166., 0.],
                           [423., 318., 310., 313., 312., 312., 308., 310.]])

nb_it_Jacobi_1 = np.array([[5., 0., 0., 0., 0., 0., 0., 0.],
                           [10., 8., 0., 0., 0., 0., 0., 0.],
                           [18., 15., 14., 0., 0., 0., 0., 0.],
                           [29., 24., 21., 18., 0., 0., 0., 0.],
                           [54., 45., 40., 36., 30., 0., 0., 0.],
                           [104., 85., 78., 70., 60., 50., 0., 0.],
                           [201., 154., 144., 134., 119., 97., 92., 0.],
                           [352., 299., 265., 243., 211., 176., 156., 156.]])
#### abs geometry
nb_it_Green_abs_1 = np.array([[7., 0., 0., 0., 0., 0., 0., 0., 0.],
                              [9., 9., 0., 0., 0., 0., 0., 0., 0.],
                              [9., 10., 9., 0., 0., 0., 0., 0., 0.],
                              [10., 10., 10., 9., 0., 0., 0., 0., 0.],
                              [10., 10., 10., 9., 9., 0., 0., 0., 0.],
                              [10., 10., 10., 9., 9., 9., 0., 0., 0.],
                              [10., 10., 10., 9., 9., 9., 9., 0., 0.],
                              [10., 10., 10., 9., 9., 9., 9., 9., 0.],
                              [10., 10., 10., 9., 9., 9., 9., 9., 9.]])

nb_it_combi_abs_1 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                              [5., 4., 0., 0., 0., 0., 0., 0., 0.],
                              [6., 5., 4., 0., 0., 0., 0., 0., 0.],
                              [7., 5., 4., 4., 0., 0., 0., 0., 0.],
                              [8., 6., 5., 4., 4., 0., 0., 0., 0.],
                              [10., 7., 6., 5., 4., 4., 0., 0., 0.],
                              [12., 9., 6., 5., 5., 4., 4., 0., 0.],
                              [18., 11., 8., 6., 5., 5., 4., 4., 0.],
                              [31., 16., 10., 7., 6., 5., 5., 4., 4.]])

nb_it_Green_abs_4 = np.array([[8., 0., 0., 0., 0., 0., 0., 0., 0.],
                              [12., 12., 0., 0., 0., 0., 0., 0., 0.],
                              [13., 15., 16., 0., 0., 0., 0., 0., 0.],
                              [14., 18., 20., 20., 0., 0., 0., 0., 0.],
                              [15., 18., 23., 26., 24., 0., 0., 0., 0.],
                              [15., 18., 24., 27., 34., 30., 0., 0., 0.],
                              [16., 19., 24., 31., 35., 39., 34., 0., 0.],
                              [16., 21., 25., 31., 36., 40., 38., 32., 0.],
                              [16., 22., 25., 31., 37., 41., 41., 33., 30.]])

nb_it_combi_abs_4 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                              [6., 5., 0., 0., 0., 0., 0., 0., 0.],
                              [8., 6., 5., 0., 0., 0., 0., 0., 0.],
                              [11., 8., 5., 4., 0., 0., 0., 0., 0.],
                              [16., 11., 8., 5., 4., 0., 0., 0., 0.],
                              [25., 17., 11., 8., 4., 4., 0., 0., 0.],
                              [45., 26., 17., 11., 8., 4., 4., 0., 0.],
                              [82., 47., 27., 17., 11., 7., 4., 4., 0.],
                              [157., 87., 50., 27., 16., 11., 6., 4., 4.]])

#  without MPI
# nb_it_Green_abs_1 = np.array([[7., 0., 0., 0., 0., 0., 0., 0.],
#                               [9., 9., 0., 0., 0., 0., 0., 0.],
#                               [10., 11., 10., 0., 0., 0., 0., 0.],
#                               [10., 11., 10., 10., 0., 0., 0., 0.],
#                               [10., 11., 10., 9., 9., 0., 0., 0.],
#                               [10., 10., 9., 9., 8., 8., 0., 0.],
#                               [9., 9., 9., 8., 8., 7., 6., 0.],
#                               [9., 8., 8., 8., 7., 6., 6., 5.]])
#
# nb_it_combi_abs_1 = np.array([[5., 0., 0., 0., 0., 0., 0., 0.],
#                               [5., 4., 0., 0., 0., 0., 0., 0.],
#                               [6., 5., 4., 0., 0., 0., 0., 0.],
#                               [7., 5., 4., 4., 0., 0., 0., 0.],
#                               [8., 6., 5., 4., 4., 0., 0., 0.],
#                               [9., 7., 5., 5., 4., 3., 0., 0.],
#                               [12., 8., 6., 5., 5., 4., 3., 0.],
#                               [17., 11., 7., 6., 5., 5., 3., 3.]])
#
# nb_it_Green_abs_4 = np.array([[8., 0., 0., 0., 0., 0., 0., 0.],
#                               [12., 12., 0., 0., 0., 0., 0., 0.],
#                               [15., 16., 18., 0., 0., 0., 0., 0.],
#                               [15., 19., 22., 23., 0., 0., 0., 0.],
#                               [15., 19., 25., 28., 27., 0., 0., 0.],
#                               [15., 19., 24., 30., 35., 32., 0., 0.],
#                               [16., 19., 23., 31., 35., 40., 32., 0.],
#                               [16., 19., 23., 30., 34., 35., 27., 18.]])
#
# nb_it_combi_abs_4 = np.array([[5., 0., 0., 0., 0., 0., 0., 0.],
#                               [6., 5., 0., 0., 0., 0., 0., 0.],
#                               [8., 6., 5., 0., 0., 0., 0., 0.],
#                               [11., 8., 6., 4., 0., 0., 0., 0.],
#                               [16., 11., 8., 5., 4., 0., 0., 0.],
#                               [24., 17., 11., 8., 4., 4., 0., 0.],
#                               [42., 26., 17., 11., 8., 4., 3., 0.],
#                               [76., 46., 27., 16., 10., 7., 4., 3.]])
#                 nb_pix_multips = [  2, 3,  4,   5,  6,  7,  8,  9, 10,]

nb_it_Green_laminate2_1 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                    [4., 8., 0., 0., 0., 0., 0., 0., 0.],
                                    [4., 8., 11., 0., 0., 0., 0., 0., 0.],
                                    [4., 8., 11., 11., 0., 0., 0., 0., 0.],
                                    [4., 8., 11., 11., 11., 0., 0., 0., 0.],
                                    [4., 8., 11., 11., 11., 11., 0., 0., 0.],
                                    [4., 8., 11., 11., 11., 11., 11., 0., 0.],
                                    [4., 8., 11., 11., 11., 11., 11., 11., 0.],
                                    [4., 8., 11., 11., 11., 11., 11., 11., 11.]])

nb_it_Green_n_laminate_1_e14 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                         [4., 8., 0., 0., 0., 0., 0., 0., 0.],
                                         [4., 8., 16., 0., 0., 0., 0., 0., 0.],
                                         [4., 8., 16., 23., 0., 0., 0., 0., 0.],
                                         [4., 8., 16., 30., 26., 0., 0., 0., 0.],
                                         [4., 8., 16., 30., 46., 26., 0., 0., 0.],
                                         [4., 8., 16., 30., 46., 66., 27., 0., 0.],
                                         [4., 8., 16., 30., 46., 66., 94., 27., 0.],
                                         [4., 8., 16., 30., 46., 66., 94., 132., 26.]])

nb_it_combi_laminate2_1 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                    [5., 4., 0., 0., 0., 0., 0., 0., 0.],
                                    [6., 5., 4., 0., 0., 0., 0., 0., 0.],
                                    [8., 6., 5., 4., 0., 0., 0., 0., 0.],
                                    [9., 8., 6., 5., 5., 0., 0., 0., 0.],
                                    [9., 9., 7., 6., 5., 5., 0., 0., 0.],
                                    [9., 11., 9., 7., 7., 5., 5., 0., 0.],
                                    [9., 15., 12., 9., 8., 7., 5., 5., 0.],
                                    [10., 20., 15., 13., 11., 9., 7., 5., 5.]])

nb_it_combi_n_laminate_1_e14 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                         [8., 6., 0., 0., 0., 0., 0., 0., 0.],
                                         [9., 10., 6., 0., 0., 0., 0., 0., 0.],
                                         [9., 14., 11., 6., 0., 0., 0., 0., 0.],
                                         [9., 17., 16., 13., 6., 0., 0., 0., 0.],
                                         [9., 21., 19., 17., 14., 7., 0., 0., 0.],
                                         [13., 22., 25., 23., 19., 14., 7., 0., 0.],
                                         [13., 25., 32., 29., 25., 21., 16., 8., 0.],
                                         [16., 30., 42., 39., 34., 29., 23., 17., 9.]])

nb_it_Green_laminate2_4 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                    [4., 8., 0., 0., 0., 0., 0., 0., 0.],
                                    [4., 8., 15., 0., 0., 0., 0., 0., 0.],
                                    [4., 8., 15., 22., 0., 0., 0., 0., 0.],
                                    [4., 8., 15., 22., 32., 0., 0., 0., 0.],
                                    [4., 8., 15., 22., 32., 45., 0., 0., 0.],
                                    [4., 8., 15., 22., 32., 45., 63., 0., 0.],
                                    [4., 8., 15., 22., 32., 45., 63., 86., 0.],
                                    [4., 8., 15., 22., 32., 45., 63., 86., 117.]])

nb_it_Green_n_laminate_4_e14 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                         [4., 8., 0., 0., 0., 0., 0., 0., 0.],
                                         [4., 8., 16., 0., 0., 0., 0., 0., 0.],
                                         [4., 8., 16., 30., 0., 0., 0., 0., 0.],
                                         [4., 8., 16., 30., 46., 0., 0., 0., 0.],
                                         [4., 8., 16., 30., 46., 66., 0., 0., 0.],
                                         [4., 8., 16., 30., 46., 66., 94., 0., 0.],
                                         [4., 8., 16., 30., 46., 66., 94., 132., 0.],
                                         [4., 8., 16., 30., 46., 66., 94., 132., 183.]])

nb_it_combi_laminate2_4 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                    [7., 4., 0., 0., 0., 0., 0., 0., 0.],
                                    [8., 7., 5., 0., 0., 0., 0., 0., 0.],
                                    [9., 9., 8., 6., 0., 0., 0., 0., 0.],
                                    [9., 11., 10., 8., 6., 0., 0., 0., 0.],
                                    [9., 14., 13., 12., 9., 7., 0., 0., 0.],
                                    [9., 19., 16., 15., 14., 10., 7., 0., 0.],
                                    [11., 22., 23., 21., 18., 15., 11., 8., 0.],
                                    [13., 27., 33., 29., 25., 21., 18., 12., 10.]])

nb_it_combi_n_laminate_4_e14 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                         [8., 6., 0., 0., 0., 0., 0., 0., 0.],
                                         [9., 10., 7., 0., 0., 0., 0., 0., 0.],
                                         [9., 14., 11., 8., 0., 0., 0., 0., 0.],
                                         [9., 17., 16., 13., 8., 0., 0., 0., 0.],
                                         [9., 21., 19., 17., 14., 9., 0., 0., 0.],
                                         [13., 22., 25., 23., 19., 14., 11., 0., 0.],
                                         [13., 25., 32., 29., 25., 21., 16., 12., 0.],
                                         [16., 30., 42., 39., 34., 29., 23., 17., 12.]])

nb_it_Green_laminate_log_1_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
     [4., 11., 16., 0., 0., 0., 0., 0., 0.],
     [4., 11., 34., 22., 0., 0., 0., 0., 0.],
     [4., 12., 36., 113., 24., 0., 0., 0., 0.],
     [4., 12., 36., 117., 253., 25., 0., 0., 0.],
     [4., 13., 38., 122., 261., 368., 25., 0., 0.],
     [4., 13., 39., 124., 264., 377., 461., 25., 0.],
     [4., 15., 44., 132., 274., 383., 466., 512., 25.]])
nb_it_combi_laminate_log_1_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [8., 6., 0., 0., 0., 0., 0., 0., 0.],
     [9., 12., 6., 0., 0., 0., 0., 0., 0.],
     [9., 14., 11., 6., 0., 0., 0., 0., 0.],
     [9., 18., 16., 10., 6., 0., 0., 0., 0.],
     [10., 20., 21., 18., 11., 6., 0., 0., 0.],
     [12., 23., 30., 23., 18., 12., 7., 0., 0.],
     [15., 29., 39., 33., 25., 20., 12., 8., 0.],
     [19., 43., 50., 47., 35., 28., 21., 13., 9.]])

nb_it_Green_laminate_log_4_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 10., 0., 0., 0., 0., 0., 0., 0.],
     [4., 11., 26., 0., 0., 0., 0., 0., 0.],
     [4., 11., 34., 85., 0., 0., 0., 0., 0.],
     [4., 12., 36., 113., 201., 0., 0., 0., 0.],
     [4., 12., 36., 117., 253., 319., 0., 0., 0.],
     [4., 13., 38., 122., 261., 368., 418., 0., 0.],
     [4., 13., 39., 124., 264., 377., 461., 489., 0.],
     [4., 15., 44., 132., 274., 383., 466., 512., 530.]])
nb_it_combi_laminate_log_4_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [8., 7., 0., 0., 0., 0., 0., 0., 0.],
     [9., 12., 9., 0., 0., 0., 0., 0., 0.],
     [9., 14., 11., 9., 0., 0., 0., 0., 0.],
     [9., 18., 16., 10., 9., 0., 0., 0., 0.],
     [10., 20., 21., 18., 11., 11., 0., 0., 0.],
     [12., 23., 30., 23., 18., 12., 12., 0., 0.],
     [15., 29., 39., 33., 25., 20., 12., 12., 0.],
     [19., 43., 50., 47., 35., 28., 21., 13., 13.]])

nb_it_Green_laminate_log_1_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
     [4., 7., 10., 0., 0., 0., 0., 0., 0.],
     [4., 7., 14., 11., 0., 0., 0., 0., 0.],
     [4., 7., 14., 29., 11., 0., 0., 0., 0.],
     [4., 7., 14., 26., 51., 11., 0., 0., 0.],
     [4., 7., 14., 30., 49., 67., 11., 0., 0.],
     [4., 7., 15., 31., 50., 71., 91., 11., 0.],
     [4., 7., 16., 28., 51., 69., 86., 99., 11.]])

nb_it_combi_laminate_log_1_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [7., 4., 0., 0., 0., 0., 0., 0., 0.],
     [8., 7., 4., 0., 0., 0., 0., 0., 0.],
     [9., 10., 7., 4., 0., 0., 0., 0., 0.],
     [9., 12., 10., 7., 5., 0., 0., 0., 0.],
     [9., 15., 14., 10., 7., 5., 0., 0., 0.],
     [9., 17., 19., 16., 12., 7., 5., 0., 0.],
     [11., 22., 27., 21., 16., 13., 9., 5., 0.],
     [14., 29., 38., 33., 24., 18., 14., 10., 5.]])

nb_it_Green_laminate_log_4_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 7., 0., 0., 0., 0., 0., 0., 0.],
     [4., 7., 13., 0., 0., 0., 0., 0., 0.],
     [4., 7., 14., 26., 0., 0., 0., 0., 0.],
     [4., 7., 14., 29., 45., 0., 0., 0., 0.],
     [4., 7., 14., 26., 51., 66., 0., 0., 0.],
     [4., 7., 14., 30., 49., 67., 82., 0., 0.],
     [4., 7., 15., 31., 50., 71., 91., 97., 0.],
     [4., 7., 16., 28., 51., 69., 86., 99., 105.], ])

nb_it_combi_laminate_log_4_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [7., 5., 0., 0., 0., 0., 0., 0., 0.],
     [8., 7., 6., 0., 0., 0., 0., 0., 0.],
     [9., 10., 7., 7., 0., 0., 0., 0., 0.],
     [9., 12., 10., 7., 7., 0., 0., 0., 0.],
     [9., 15., 14., 10., 7., 7., 0., 0., 0.],
     [9., 17., 19., 16., 12., 7., 7., 0., 0.],
     [11., 22., 27., 21., 16., 13., 9., 9., 0.],
     [14., 29., 38., 33., 24., 18., 14., 10., 10.]])

nb_it_Green_n_laminate_1_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 11., 0., 0., 0., 0., 0., 0.],
     [4., 8., 15., 12., 0., 0., 0., 0., 0.],
     [4., 8., 15., 22., 12., 0., 0., 0., 0.],
     [4., 8., 15., 22., 32., 12., 0., 0., 0.],
     [4., 8., 15., 22., 32., 45., 12., 0., 0.],
     [4., 8., 15., 22., 32., 45., 63., 12., 0.],
     [4., 8., 15., 22., 32., 45., 63., 86., 12.]])

nb_it_combi_n_laminate_1_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [7., 4., 0., 0., 0., 0., 0., 0., 0.],
     [8., 7., 4., 0., 0., 0., 0., 0., 0.],
     [9., 9., 8., 5., 0., 0., 0., 0., 0.],
     [9., 11., 10., 8., 5., 0., 0., 0., 0.],
     [9., 14., 13., 12., 9., 5., 0., 0., 0.],
     [9., 19., 16., 15., 14., 10., 5., 0., 0.],
     [11., 22., 23., 21., 18., 15., 11., 5., 0.],
     [13., 27., 33., 29., 25., 21., 18., 12., 5.]])
nb_it_Green_n_laminate_4_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 15., 0., 0., 0., 0., 0., 0.],
     [4., 8., 15., 22., 0., 0., 0., 0., 0.],
     [4., 8., 15., 22., 32., 0., 0., 0., 0.],
     [4., 8., 15., 22., 32., 45., 0., 0., 0.],
     [4., 8., 15., 22., 32., 45., 63., 0., 0.],
     [4., 8., 15., 22., 32., 45., 63., 86., 0.],
     [4., 8., 15., 22., 32., 45., 63., 86., 117.]])
nb_it_combi_n_laminate_4_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [7., 4., 0., 0., 0., 0., 0., 0., 0.],
     [8., 7., 5., 0., 0., 0., 0., 0., 0.],
     [9., 9., 8., 6., 0., 0., 0., 0., 0.],
     [9., 11., 10., 8., 6., 0., 0., 0., 0.],
     [9., 14., 13., 12., 9., 7., 0., 0., 0.],
     [9., 19., 16., 15., 14., 10., 7., 0., 0.],
     [11., 22., 23., 21., 18., 15., 11., 8., 0.],
     [13., 27., 33., 29., 25., 21., 18., 12., 10.]])
###################################### LEFT CLUSTER X3
nb_it_Green_left_cluster_x3_1_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 15., 0., 0., 0., 0., 0., 0.],
     [4., 8., 15., 21., 0., 0., 0., 0., 0.],
     [4., 8., 15., 21., 24., 0., 0., 0., 0.],
     [4., 8., 15., 21., 24., 24., 0., 0., 0.],
     [4., 8., 15., 21., 24., 24., 25., 0., 0.],
     [4., 8., 15., 21., 24., 24., 25., 25., 0.],
     [4., 8., 15., 21., 24., 24., 25., 25., 25.]])

nb_it_combi_left_cluster_x3_1_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [8., 6., 0., 0., 0., 0., 0., 0., 0.],
     [9., 8., 6., 0., 0., 0., 0., 0., 0.],
     [9., 10., 8., 7., 0., 0., 0., 0., 0.],
     [9., 12., 10., 7., 7., 0., 0., 0., 0.],
     [9., 15., 12., 10., 7., 7., 0., 0., 0.],
     [9., 18., 16., 14., 11., 7., 7., 0., 0.],
     [11., 20., 18., 16., 14., 13., 8., 8., 0.],
     [12., 22., 26., 19., 17., 15., 13., 10., 9.]])
nb_it_Green_left_cluster_x3_4_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 18., 0., 0., 0., 0., 0., 0.],
     [4., 8., 19., 47., 0., 0., 0., 0., 0.],
     [4., 8., 20., 50., 125., 0., 0., 0., 0.],
     [4., 8., 20., 51., 135., 301., 0., 0., 0.],
     [4., 8., 20., 52., 136., 301., 469., 0., 0.],
     [4., 8., 21., 54., 141., 327., 487., 552., 0.],
     [4., 9., 22., 56., 147., 337., 493., 562., 578.]])
nb_it_combi_left_cluster_x3_4_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [8., 6., 0., 0., 0., 0., 0., 0., 0.],
     [9., 12., 7., 0., 0., 0., 0., 0., 0.],
     [9., 15., 12., 8., 0., 0., 0., 0., 0.],
     [9., 18., 18., 11., 8., 0., 0., 0., 0.],
     [9., 21., 23., 18., 11., 9., 0., 0., 0.],
     [12., 23., 32., 26., 18., 11., 11., 0., 0.],
     [13., 26., 44., 37., 27., 20., 11., 11., 0.],
     [18., 35., 60., 54., 38., 29., 22., 12., 12.]])

###################################### Right CLUSTER X3

nb_it_Green_right_cluster_x3_1_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 12., 0., 0., 0., 0., 0., 0.],
     [4., 8., 12., 17., 0., 0., 0., 0., 0.],
     [4., 8., 12., 17., 21., 0., 0., 0., 0.],
     [4., 8., 12., 17., 21., 24., 0., 0., 0.],
     [4., 8., 12., 17., 21., 24., 25., 0., 0.],
     [4., 8., 12., 17., 21., 24., 25., 25., 0.],
     [4., 8., 12., 17., 21., 24., 25., 25., 25.]])
nb_it_combi_right_cluster_x3_1_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [8., 6., 0., 0., 0., 0., 0., 0., 0.],
     [9., 9., 7., 0., 0., 0., 0., 0., 0.],
     [9., 11., 9., 7., 0., 0., 0., 0., 0.],
     [9., 12., 12., 9., 7., 0., 0., 0., 0.],
     [9., 14., 14., 13., 9., 8., 0., 0., 0.],
     [9., 17., 17., 16., 12., 8., 8., 0., 0.],
     [12., 21., 21., 19., 16., 13., 10., 10., 0.],
     [13., 25., 27., 23., 20., 16., 14., 10., 10.]])
nb_it_Green_right_cluster_x3_4_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 13., 0., 0., 0., 0., 0., 0.],
     [4., 8., 13., 20., 0., 0., 0., 0., 0.],
     [4., 8., 13., 20., 28., 0., 0., 0., 0.],
     [4., 8., 13., 20., 28., 40., 0., 0., 0.],
     [4., 8., 13., 20., 28., 40., 56., 0., 0.],
     [4., 8., 13., 20., 28., 40., 56., 79., 0.],
     [4., 8., 13., 20., 28., 40., 56., 79., 111.]])
nb_it_combi_right_cluster_x3_4_e14 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [8., 7., 0., 0., 0., 0., 0., 0., 0.],
     [9., 10., 7., 0., 0., 0., 0., 0., 0.],
     [9., 12., 11., 8., 0., 0., 0., 0., 0.],
     [9., 15., 16., 14., 9., 0., 0., 0., 0.],
     [9., 18., 18., 17., 14., 9., 0., 0., 0.],
     [12., 21., 23., 22., 19., 14., 12., 0., 0.],
     [13., 25., 29., 28., 25., 21., 17., 12., 0.],
     [14., 28., 36., 36., 34., 29., 24., 17., 14.]])

nb_it_Green_right_cluster_x3_1_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 7., 0., 0., 0., 0., 0., 0., 0.],
     [4., 7., 9., 0., 0., 0., 0., 0., 0.],
     [4., 7., 9., 10., 0., 0., 0., 0., 0.],
     [4., 7., 9., 10., 11., 0., 0., 0., 0.],
     [4., 7., 9., 10., 11., 11., 0., 0., 0.],
     [4., 7., 9., 10., 11., 11., 11., 0., 0.],
     [4., 7., 9., 10., 11., 11., 11., 11., 0.],
     [4., 7., 9., 10., 11., 11., 11., 11., 11.]])
nb_it_combi_right_cluster_x3_1_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [5., 4., 0., 0., 0., 0., 0., 0., 0.],
     [6., 6., 5., 0., 0., 0., 0., 0., 0.],
     [7., 7., 6., 5., 0., 0., 0., 0., 0.],
     [8., 9., 8., 6., 5., 0., 0., 0., 0.],
     [9., 10., 9., 8., 6., 6., 0., 0., 0.],
     [9., 11., 11., 9., 8., 6., 6., 0., 0.],
     [9., 15., 15., 13., 9., 8., 6., 6., 0.],
     [11., 19., 19., 15., 13., 11., 9., 6., 6.]])

nb_it_Green_right_cluster_x3_4_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 7., 0., 0., 0., 0., 0., 0., 0.],
     [4., 7., 10., 0., 0., 0., 0., 0., 0.],
     [4., 7., 10., 14., 0., 0., 0., 0., 0.],
     [4., 7., 10., 14., 20., 0., 0., 0., 0.],
     [4., 7., 10., 14., 20., 28., 0., 0., 0.],
     [4., 7., 10., 14., 20., 28., 39., 0., 0.],
     [4., 7., 10., 14., 20., 28., 39., 54., 0.],
     [4., 7., 10., 14., 20., 28., 39., 54., 75.]])
nb_it_combi_right_cluster_x3_4_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [6., 5., 0., 0., 0., 0., 0., 0., 0.],
     [8., 7., 5., 0., 0., 0., 0., 0., 0.],
     [9., 9., 8., 6., 0., 0., 0., 0., 0.],
     [9., 10., 10., 8., 6., 0., 0., 0., 0.],
     [9., 13., 13., 12., 9., 7., 0., 0., 0.],
     [9., 16., 17., 15., 14., 10., 7., 0., 0.],
     [11., 20., 22., 21., 18., 15., 12., 9., 0.],
     [13., 24., 27., 29., 25., 22., 18., 12., 10.]])

nb_it_Green_left_cluster_x3_1_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 7., 0., 0., 0., 0., 0., 0., 0.],
     [4., 7., 9., 0., 0., 0., 0., 0., 0.],
     [4., 7., 9., 10., 0., 0., 0., 0., 0.],
     [4., 7., 9., 10., 11., 0., 0., 0., 0.],
     [4., 7., 9., 10., 11., 11., 0., 0., 0.],
     [4., 7., 9., 10., 11., 11., 11., 0., 0.],
     [4., 7., 9., 10., 11., 11., 11., 11., 0.],
     [4., 7., 9., 10., 11., 11., 11., 11., 11.]])

nb_it_combi_left_cluster_x3_1_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [5., 4., 0., 0., 0., 0., 0., 0., 0.],
     [6., 5., 5., 0., 0., 0., 0., 0., 0.],
     [7., 6., 5., 5., 0., 0., 0., 0., 0.],
     [8., 7., 6., 5., 5., 0., 0., 0., 0.],
     [8., 9., 7., 7., 5., 5., 0., 0., 0.],
     [9., 10., 9., 8., 7., 5., 5., 0., 0.],
     [9., 15., 12., 9., 8., 7., 5., 5., 0.],
     [11., 19., 15., 13., 12., 9., 8., 6., 6.]])

nb_it_Green_left_cluster_x3_4_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
     [4., 8., 17., 0., 0., 0., 0., 0., 0.],
     [4., 8., 17., 37., 0., 0., 0., 0., 0.],
     [4., 8., 17., 40., 73., 0., 0., 0., 0.],
     [4., 8., 17., 40., 77., 104., 0., 0., 0.],
     [4., 8., 17., 41., 78., 109., 123., 0., 0.],
     [4., 8., 18., 42., 79., 108., 125., 130., 0.],
     [4., 8., 19., 42., 80., 111., 123., 128., 130.]])

nb_it_combi_left_cluster_x3_4_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [7., 4., 0., 0., 0., 0., 0., 0., 0.],
     [8., 7., 5., 0., 0., 0., 0., 0., 0.],
     [9., 10., 7., 6., 0., 0., 0., 0., 0.],
     [9., 13., 11., 6., 6., 0., 0., 0., 0.],
     [9., 17., 16., 10., 7., 7., 0., 0., 0.],
     [9., 21., 21., 16., 12., 7., 7., 0., 0.],
     [11., 23., 31., 24., 16., 13., 7., 7., 0.],
     [13., 29., 48., 35., 25., 18., 14., 8., 8.]])

nb_it_Green_linear_1_e14 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 24., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 24., 27., 0., 0., 0., 0.],
                                     [4., 8., 16., 24., 27., 28., 0., 0., 0.],
                                     [4., 8., 16., 24., 27., 28., 28., 0., 0.],
                                     [4., 8., 16., 24., 27., 28., 28., 28., 0.],
                                     [4., 8., 16., 24., 27., 28., 28., 28., 28.]])

nb_it_combi_linear_1_e14 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [8., 6., 0., 0., 0., 0., 0., 0., 0.],
                                     [9., 9., 6., 0., 0., 0., 0., 0., 0.],
                                     [9., 11., 9., 7., 0., 0., 0., 0., 0.],
                                     [9., 13., 11., 8., 7., 0., 0., 0., 0.],
                                     [10., 16., 14., 12., 8., 7., 0., 0., 0.],
                                     [10., 19., 16., 14., 12., 8., 8., 0., 0.],
                                     [11., 20., 20., 17., 14., 12., 8., 8., 0.],
                                     [11., 22., 25., 19., 17., 15., 12., 8., 8.]])

nb_it_Green_linear_4_e14 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 32., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 32., 54., 0., 0., 0., 0.],
                                     [4., 8., 16., 32., 54., 80., 0., 0., 0.],
                                     [4., 8., 16., 32., 54., 80., 115., 0., 0.],
                                     [4., 8., 16., 32., 54., 80., 115., 163., 0.],
                                     [4., 8., 16., 32., 55., 80., 115., 163., 229.]])

nb_it_combi_linear_4_e14 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [8., 8., 0., 0., 0., 0., 0., 0., 0.],
                                     [9., 14., 9., 0., 0., 0., 0., 0., 0.],
                                     [10., 17., 15., 10., 0., 0., 0., 0., 0.],
                                     [10., 19., 18., 15., 11., 0., 0., 0., 0.],
                                     [11., 20., 23., 21., 17., 12., 0., 0., 0.],
                                     [12., 22., 29., 26., 23., 17., 12., 0., 0.],
                                     [16., 24., 36., 33., 29., 25., 18., 14., 0.],
                                     [17., 29., 44., 42., 37., 31., 27., 19., 14.]])

nb_it_Green_linear_1_e14 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 24., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 24., 27., 0., 0., 0., 0.],
                                     [4., 8., 16., 24., 27., 28., 0., 0., 0.],
                                     [4., 8., 16., 24., 27., 28., 28., 0., 0.],
                                     [4., 8., 16., 24., 27., 28., 28., 28., 0.],
                                     [4., 8., 16., 24., 27., 28., 28., 28., 28.]])
nb_it_Green_linear_1_e06 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 13., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 13., 14., 0., 0., 0., 0., 0.],
                                     [4., 8., 13., 14., 14., 0., 0., 0., 0.],
                                     [4., 8., 13., 14., 14., 14., 0., 0., 0.],
                                     [4., 8., 13., 14., 14., 14., 14., 0., 0.],
                                     [4., 8., 13., 14., 14., 14., 14., 14., 0.],
                                     [4., 8., 13., 14., 14., 14., 14., 14., 14.]])

nb_it_combi_linear_1_e14 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [8., 6., 0., 0., 0., 0., 0., 0., 0.],
                                     [9., 9., 6., 0., 0., 0., 0., 0., 0.],
                                     [9., 11., 9., 7., 0., 0., 0., 0., 0.],
                                     [9., 13., 11., 8., 7., 0., 0., 0., 0.],
                                     [10., 16., 14., 12., 8., 7., 0., 0., 0.],
                                     [10., 19., 16., 14., 12., 8., 8., 0., 0.],
                                     [11., 20., 20., 17., 14., 12., 8., 8., 0.],
                                     [11., 22., 25., 19., 17., 15., 12., 8., 8.]])
nb_it_combi_linear_1_e06 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [6., 4., 0., 0., 0., 0., 0., 0., 0.],
                                     [8., 6., 5., 0., 0., 0., 0., 0., 0.],
                                     [9., 7., 6., 5., 0., 0., 0., 0., 0.],
                                     [9., 9., 7., 6., 5., 0., 0., 0., 0.],
                                     [9., 10., 8., 7., 5., 5., 0., 0., 0.],
                                     [9., 13., 11., 8., 7., 5., 5., 0., 0.],
                                     [10., 16., 13., 11., 10., 7., 6., 5., 0.],
                                     [11., 20., 17., 13., 11., 10., 9., 6., 6.]])

################## ################## LINEAR  FOR 10^6 precision ################## ################## ##################
nb_it_Green_linear_2_e06 = np.array([
    [4., 0., 0., 0., 0., 0., 0., 0., 0.],
    [4., 8., 0., 0., 0., 0., 0., 0., 0.],
    [4., 8., 16., 0., 0., 0., 0., 0., 0.],
    [4., 8., 16., 25., 0., 0., 0., 0., 0.],
    [4., 8., 16., 25., 34., 0., 0., 0., 0.],
    [4., 8., 16., 25., 34., 43., 0., 0., 0.],
    [4., 8., 16., 25., 34., 43., 50., 0., 0.],
    [4., 8., 16., 25., 34., 43., 50., 52., 0.],
    [4., 8., 16., 25., 34., 43., 50., 52., 52.]])

nb_it_Jacobi_linear_2_e06 = np.array([
    [7., 0., 0., 0., 0., 0., 0., 0., 0.],
    [11., 15., 0., 0., 0., 0., 0., 0., 0.],
    [21., 28., 31., 0., 0., 0., 0., 0., 0.],
    [49., 65., 69., 68., 0., 0., 0., 0., 0.],
    [105., 130., 144., 144., 143., 0., 0., 0., 0.],
    [212., 274., 297., 301., 296., 287., 0., 0., 0.],
    [438., 569., 615., 624., 615., 592., 589., 0., 0.],
    [892., 1000., 1000., 1000., 1000., 1000., 1000., 1000., 0.],
    [1000., 1000., 1000., 1000., 1000., 1000., 1000., 1000., 1000.]])

nb_it_combi_linear_2_e06 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [8., 5., 0., 0., 0., 0., 0., 0., 0.],
                                     [9., 8., 6., 0., 0., 0., 0., 0., 0.],
                                     [9., 11., 9., 6., 0., 0., 0., 0., 0.],
                                     [9., 12., 11., 9., 7., 0., 0., 0., 0.],
                                     [9., 15., 14., 13., 8., 7., 0., 0., 0.],
                                     [10., 19., 19., 15., 13., 9., 7., 0., 0.],
                                     [11., 20., 22., 20., 16., 12., 9., 8., 0.],
                                     [11., 23., 29., 24., 20., 16., 13., 8., 8.]])
nb_it_Green_linear_4_e06 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 0., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 0., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 30., 0., 0., 0., 0., 0.],
                                     [4., 8., 16., 30., 46., 0., 0., 0., 0.],
                                     [4., 8., 16., 30., 46., 66., 0., 0., 0.],
                                     [4., 8., 16., 30., 46., 66., 93., 0., 0.],
                                     [4., 8., 16., 30., 46., 66., 93., 131., 0.],
                                     [4., 8., 16., 30., 46., 66., 93., 131., 182.]])

nb_it_Jacobi_linear_4_e06 = np.array(
    [[7., 0., 0., 0., 0., 0., 0., 0., 0.],
     [11., 15., 0., 0., 0., 0., 0., 0., 0.],
     [22., 29., 33., 0., 0., 0., 0., 0., 0.],
     [52., 67., 73., 77., 0., 0., 0., 0., 0.],
     [107., 137., 150., 154., 156., 0., 0., 0., 0.],
     [219., 283., 314., 323., 327., 329., 0., 0., 0.],
     [447., 579., 643., 663., 673., 676., 681., 0., 0.],
     [900., 1000., 1000., 1000., 1000., 1000., 1000., 1000., 0.],
     [1000., 1000., 1000., 1000., 1000., 1000., 1000., 1000., 1000.]])

nb_it_combi_linear_4_e06 = np.array([[4., 0., 0., 0., 0., 0., 0., 0., 0.],
                                     [8., 6., 0., 0., 0., 0., 0., 0., 0.],
                                     [9., 10., 7., 0., 0., 0., 0., 0., 0.],
                                     [9., 14., 12., 8., 0., 0., 0., 0., 0.],
                                     [9., 16., 15., 12., 8., 0., 0., 0., 0.],
                                     [11., 20., 19., 16., 13., 10., 0., 0., 0.],
                                     [11., 20., 22., 21., 18., 14., 10., 0., 0.],
                                     [11., 23., 29., 27., 23., 20., 14., 11., 0.],
                                     [12., 25., 35., 34., 31., 25., 21., 15., 11.]])

################## ################## ##################  SINE WAVE FOR 10^6 precision   ################## ################## ##################
nb_it_Green_sine_wave_0_e06 = np.array(
    [[5., 0., 0., 0., 0., 0., 0., 0., 0.],
     [7., 9., 0., 0., 0., 0., 0., 0., 0.],
     [8., 12., 17., 0., 0., 0., 0., 0., 0.],
     [9., 15., 22., 26., 0., 0., 0., 0., 0.],
     [9., 15., 24., 39., 46., 0., 0., 0., 0.],
     [9., 15., 27., 40., 64., 59., 0., 0., 0.],
     [9., 17., 28., 44., 64., 77., 65., 0., 0.],
     [10., 17., 28., 45., 65., 81., 67., 67., 0.],
     [10., 18., 28., 46., 66., 82., 67., 67., 67.]])

nb_it_Jacobi_sine_wave_0_e06 = np.array(
    [[5., 0., 0., 0., 0., 0., 0., 0., 0.],
     [8., 8., 0., 0., 0., 0., 0., 0., 0.],
     [20., 16., 15., 0., 0., 0., 0., 0., 0.],
     [42., 32., 30., 29., 0., 0., 0., 0., 0.],
     [86., 65., 60., 58., 58., 0., 0., 0., 0.],
     [173., 130., 120., 117., 116., 115., 0., 0., 0.],
     [346., 260., 241., 235., 232., 230., 230., 0., 0.],
     [691., 520., 483., 470., 464., 461., 459., 459., 0.],
     [1000., 1000., 966., 939., 927., 922., 919., 918., 917.]])

nb_it_combi_sine_wave_0_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [5., 4., 0., 0., 0., 0., 0., 0., 0.],
     [6., 5., 4., 0., 0., 0., 0., 0., 0.],
     [7., 7., 5., 4., 0., 0., 0., 0., 0.],
     [9., 9., 7., 5., 4., 0., 0., 0., 0.],
     [12., 12., 10., 8., 5., 5., 0., 0., 0.],
     [19., 18., 15., 12., 8., 5., 5., 0., 0.],
     [31., 30., 24., 18., 14., 9., 5., 5., 0.],
     [54., 52., 41., 31., 21., 15., 9., 5., 5.]])

nb_it_Green_sine_wave_2_e06 = np.array(
    [[5., 0., 0., 0., 0., 0., 0., 0., 0.],
     [7., 9., 0., 0., 0., 0., 0., 0., 0.],
     [8., 11., 14., 0., 0., 0., 0., 0., 0.],
     [9., 14., 19., 21., 0., 0., 0., 0., 0.],
     [9., 14., 19., 22., 22., 0., 0., 0., 0.],
     [9., 14., 20., 22., 22., 22., 0., 0., 0.],
     [9., 15., 21., 22., 22., 22., 22., 0., 0.],
     [9., 15., 21., 22., 22., 22., 22., 22., 0.],
     [9., 16., 21., 22., 22., 22., 22., 22., 22.]])

nb_it_Jacobi_sine_wave_2_e06 = np.array(
    [[5., 0., 0., 0., 0., 0., 0., 0., 0.],
     [8., 8., 0., 0., 0., 0., 0., 0., 0.],
     [20., 15., 15., 0., 0., 0., 0., 0., 0.],
     [42., 31., 29., 28., 0., 0., 0., 0., 0.],
     [85., 64., 59., 57., 55., 0., 0., 0., 0.],
     [170., 128., 118., 114., 110., 106., 0., 0., 0.],
     [341., 255., 236., 228., 222., 215., 207., 0., 0.],
     [680., 511., 471., 456., 444., 434., 421., 412., 0.],
     [1000., 1000., 941., 911., 890., 869., 848., 826., 822.]])

nb_it_combi_sine_wave_2_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [5., 4., 0., 0., 0., 0., 0., 0., 0.],
     [7., 5., 4., 0., 0., 0., 0., 0., 0.],
     [9., 7., 5., 4., 0., 0., 0., 0., 0.],
     [14., 10., 7., 5., 4., 0., 0., 0., 0.],
     [25., 13., 9., 7., 4., 4., 0., 0., 0.],
     [48., 23., 12., 9., 7., 4., 4., 0., 0.],
     [94., 42., 20., 11., 9., 7., 4., 4., 0.],
     [185., 82., 34., 20., 11., 9., 7., 4., 4.]])
nb_it_Green_sine_wave_4_e06 = np.array(
    [[5., 0., 0., 0., 0., 0., 0., 0., 0.],
     [7., 9., 0., 0., 0., 0., 0., 0., 0.],
     [8., 12., 17., 0., 0., 0., 0., 0., 0.],
     [9., 15., 22., 26., 0., 0., 0., 0., 0.],
     [9., 15., 24., 39., 45., 0., 0., 0., 0.],
     [9., 15., 27., 40., 61., 55., 0., 0., 0.],
     [9., 17., 28., 43., 62., 59., 59., 0., 0.],
     [9., 17., 28., 45., 64., 60., 60., 60., 0.],
     [10., 18., 28., 45., 64., 61., 60., 60., 60.]])

nb_it_Jacobi_sine_wave_4_e06 = np.array(
    [[5., 0., 0., 0., 0., 0., 0., 0., 0.],
     [8., 8., 0., 0., 0., 0., 0., 0., 0.],
     [20., 16., 15., 0., 0., 0., 0., 0., 0.],
     [42., 32., 30., 29., 0., 0., 0., 0., 0.],
     [86., 65., 60., 58., 58., 0., 0., 0., 0.],
     [173., 130., 120., 117., 116., 115., 0., 0., 0.],
     [345., 260., 241., 235., 232., 230., 229., 0., 0.],
     [691., 520., 483., 470., 463., 461., 458., 457., 0.],
     [1000., 1000., 965., 939., 927., 921., 918., 914., 911.]])

nb_it_combi_sine_wave_4_e06 = np.array(
    [[4., 0., 0., 0., 0., 0., 0., 0., 0.],
     [5., 4., 0., 0., 0., 0., 0., 0., 0.],
     [8., 5., 4., 0., 0., 0., 0., 0., 0.],
     [10., 8., 5., 4., 0., 0., 0., 0., 0.],
     [18., 11., 8., 5., 4., 0., 0., 0., 0.],
     [35., 22., 13., 8., 5., 5., 0., 0., 0.],
     [69., 38., 21., 14., 8., 5., 5., 0., 0.],
     [132., 78., 40., 22., 14., 8., 5., 5., 0.],
     [266., 150., 82., 43., 22., 13., 8., 5., 5.]])
#################################################### sine wave

nb_it_Green_sine_wave_0_e14 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                                        [9., 14., 0., 0., 0., 0., 0., 0., 0.],
                                        [14., 23., 28., 0., 0., 0., 0., 0., 0.],
                                        [15., 30., 46., 54., 0., 0., 0., 0., 0.],
                                        [17., 33., 58., 91., 104., 0., 0., 0., 0.],
                                        [19., 36., 64., 112., 172., 198., 0., 0., 0.],
                                        [20., 37., 68., 118., 201., 334., 370., 0., 0.],
                                        [20., 39., 71., 127., 220., 369., 608., 703., 0.],
                                        [21., 40., 73., 134., 237., 401., 679., 1095., 1305.]])

nb_it_Jacobi_sine_wave_0_e14 = np.array([
    [5., 0., 0., 0., 0., 0., 0., 0., 0.],
    [15., 0., 0., 0., 0., 0., 0., 0., 0.],
    [36., 0., 0., 0., 0., 0., 0., 0., 0.],
    [79., 0., 0., 0., 0., 0., 0., 0., 0.],
    [165., 0., 0., 0., 0., 0., 0., 0., 0.],
    [337., 0., 0., 0., 0., 0., 0., 0., 0.],
    [5000., 0., 0., 0., 0., 0., 0., 0., 0.],
    [5000., 0., 0., 0., 0., 0., 0., 0., 0.],
    [0., 0., 0., 0., 0., 0., 0., 0., 0.]])

nb_it_combi_sine_wave_0_e14 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                                        [9., 7., 0., 0., 0., 0., 0., 0., 0.],
                                        [11., 10., 8., 0., 0., 0., 0., 0., 0.],
                                        [14., 14., 12., 8., 0., 0., 0., 0., 0.],
                                        [17., 20., 17., 12., 9., 0., 0., 0., 0.],
                                        [29., 29., 25., 18., 13., 9., 0., 0., 0.],
                                        [43., 42., 38., 29., 19., 11., 10., 0., 0.],
                                        [68., 67., 62., 45., 33., 22., 14., 10., 0.],
                                        [115., 117., 102., 73., 53., 35., 22., 12., 11.], ])

nb_it_Green_sine_wave_4_e14 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                                        [9., 14., 0., 0., 0., 0., 0., 0., 0.],
                                        [14., 23., 28., 0., 0., 0., 0., 0., 0.],
                                        [15., 30., 46., 54., 0., 0., 0., 0., 0.],
                                        [17., 33., 58., 90., 103., 0., 0., 0., 0.],
                                        [19., 36., 64., 111., 170., 191., 0., 0., 0.],
                                        [20., 37., 68., 115., 195., 291., 326., 0., 0.],
                                        [20., 39., 71., 125., 206., 327., 399., 433., 0.],
                                        [21., 40., 73., 133., 224., 332., 443., 488., 489.]])
nb_it_Jacobi_sine_wave_4_e14 = np.array([
    [5., 0., 0., 0., 0., 0., 0., 0., 0.],
    [15., 0., 0., 0., 0., 0., 0., 0., 0.],
    [37., 0, 0., 0., 0., 0., 0., 0., 0.],
    [79., 0., 0., 0., 0., 0., 0., 0., 0.],
    [165., 0., 0., 0., 0., 0., 0., 0., 0.],
    [336., 0., 0., 0., 0., 0., 0., 0., 0.],
    [0., 0., 0., 0., 0., 0., 0., 0., 0.],
    [0., 0., 0., 0., 0., 0., 0., 0., 0.],
    [0., 0., 0., 0., 0., 0., 0., 0., 0.]])

nb_it_combi_sine_wave_4_e14 = np.array([[5., 0., 0., 0., 0., 0., 0., 0., 0.],
                                        [9., 7., 0., 0., 0., 0., 0., 0., 0.],
                                        [15., 10., 8., 0., 0., 0., 0., 0., 0.],
                                        [25., 18., 10., 8., 0., 0., 0., 0., 0.],
                                        [41., 29., 20., 10., 9., 0., 0., 0., 0.],
                                        [72., 48., 31., 20., 10., 9., 0., 0., 0.],
                                        [136., 83., 52., 34., 20., 11., 9., 0., 0.],
                                        [264., 160., 96., 57., 32., 19., 10., 10., 0.],
                                        [530., 317., 180., 106., 60., 32., 19., 10., 10.]])

#################################################### Linear function


nb_it_Jacobi_linear_1_e14 = np.array([[7., 0., 0., 0., 0., 0., 0., 0., 0.],
                                      [11., 15., 0., 0., 0., 0., 0., 0., 0.],
                                      [22., 30., 0., 0., 0., 0., 0., 0., 0.],
                                      [52., 68., 0., 0., 0., 0., 0., 0., 0.],
                                      [108., 135., 0., 0., 0., 0., 0., 0., 0.],
                                      [219., 283., 0., 0., 0., 0., 0., 0., 0.],
                                      [448., 579., 0., 0., 0., 0., 0., 0., 0.],
                                      [904., 0., 0., 0., 0., 0., 0., 0., 0.],
                                      [1816., 0., 0., 0., 0., 0., 0., 0., 0.]])
nb_it_Jacobi_linear_1_e06 = np.array([[7., 0., 0., 0., 0., 0., 0., 0., 0.],
                                      [11., 15., 0., 0., 0., 0., 0., 0., 0.],
                                      [21., 25., 27., 0., 0., 0., 0., 0., 0.],
                                      [47., 56., 57., 57., 0., 0., 0., 0., 0.],
                                      [102., 122., 123., 123., 122., 0., 0., 0., 0.],
                                      [205., 247., 256., 258., 258., 258., 0., 0., 0.],
                                      [426., 511., 524., 523., 523., 524., 525., 0., 0.],
                                      [878., 1000., 1000., 1000., 1000., 1000., 1000., 1000., 0.],
                                      [1000., 1000., 1000., 1000., 1000., 1000., 1000., 1000., 1000.]])

nb_it_Jacobi_linear_4_e14 = np.array([
    [7., 0., 0., 0., 0., 0., 0., 0., 0.],
    [12., 15., 0., 0., 0., 0., 0., 0., 0.],
    [25., 33., 0., 0., 0., 0., 0., 0., 0.],
    [54., 69., 0., 0., 0., 0., 0., 0., 0.],
    [111., 143., 0., 0., 0., 0., 0., 0., 0.],
    [227., 293., 0., 0., 0., 0., 0., 0., 0.],
    [458., 592., 0., 0., 0., 0., 0., 0., 0.],
    [918., 0., 0., 0., 0., 0., 0., 0., 0.],
    [1832., 0., 0., 0., 0., 0., 0., 0., 0.]])

nb_it_Green_n_laminate_sinrhs_1_e14 = np.array(
    [[13., 0., 0., 0., 0., 0., 0., 0., 0.],
     [16., 17., 0., 0., 0., 0., 0., 0., 0.],
     [16., 20., 20., 0., 0., 0., 0., 0., 0.],
     [16., 20., 22., 23., 0., 0., 0., 0., 0.],
     [16., 20., 22., 23., 24., 0., 0., 0., 0.],
     [16., 20., 22., 23., 24., 25., 0., 0., 0.],
     [16., 20., 22., 23., 24., 25., 25., 0., 0.],
     [16., 20., 22., 23., 24., 25., 25., 25., 0.],
     [16., 20., 22., 23., 24., 25., 25., 25., 25.]])

nb_it_combi_n_laminate_sinrhs_1_e14 = np.array([[11., 0., 0., 0., 0., 0., 0., 0., 0.],
                                                [13., 12., 0., 0., 0., 0., 0., 0., 0.],
                                                [16., 15., 14., 0., 0., 0., 0., 0., 0.],
                                                [22., 19., 16., 15., 0., 0., 0., 0., 0.],
                                                [30., 26., 23., 18., 17., 0., 0., 0., 0.],
                                                [41., 36., 31., 27., 19., 19., 0., 0., 0.],
                                                [59., 56., 46., 39., 33., 25., 24., 0., 0.],
                                                [85., 90., 74., 61., 52., 45., 33., 32., 0.],
                                                [129., 157., 123., 101., 86., 74., 65., 47., 47.]])

nb_it_Green_n_laminate_sinrhs_4_e14 = np.array([[14., 0., 0., 0., 0., 0., 0., 0., 0.],
                                                [22., 25., 0., 0., 0., 0., 0., 0., 0.],
                                                [24., 38., 38., 0., 0., 0., 0., 0., 0.],
                                                [24., 38., 57., 56., 0., 0., 0., 0., 0.],
                                                [24., 38., 57., 83., 81., 0., 0., 0., 0.],
                                                [24., 38., 57., 83., 115., 99., 0., 0., 0.],
                                                [24., 38., 57., 83., 115., 147., 123., 0., 0.],
                                                [24., 38., 57., 83., 115., 147., 123., 163., 0.],
                                                [24., 38., 57., 83., 115., 147., 124., 163., 210.]])

nb_it_combi_n_laminate_sinrhs_4_e14 = np.array([[12., 0., 0., 0., 0., 0., 0., 0., 0.],
                                                [16., 14., 0., 0., 0., 0., 0., 0., 0.],
                                                [25., 20., 16., 0., 0., 0., 0., 0., 0.],
                                                [35., 34., 29., 20., 0., 0., 0., 0., 0.],
                                                [51., 49., 46., 41., 25., 0., 0., 0., 0.],
                                                [75., 86., 75., 72., 62., 34., 0., 0., 0.],
                                                [110., 148., 131., 127., 117., 91., 50., 0., 0.],
                                                [186., 251., 223., 217., 199., 179., 136., 73., 0.],
                                                [317., 421., 418., 386., 349., 316., 274., 198., 111.]])

# nb_pix_multips = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#
plot_jacobi_single = False
if plot_jacobi_single:
    nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10]
    Nx = (np.asarray(nb_pix_multips))
    X, Y = np.meshgrid(Nx, Nx, indexing='ij')

    nb_pix_multips = [2, 4, 10]
    # material distribution
    geometry_ID = 'linear'  # laminate2  sine_wave_rapid     # 'abs_val' sine_wave_   ,laminate_log  geometry_ID = 'right_cluster_x3'  # laminate2       # 'abs_val' sine_wave_   ,laminate_log
    # rhs = 'sin_wave'
    rhs = False
    linestyles = ['-', '--', ':']
    colors = ['red', 'blue', 'green', 'orange', 'purple']
    precc = 6
    for phase_contrast in [1, 4]:
        ratio = phase_contrast
        fig = plt.figure(figsize=(4.5, 3.5))
        gs = fig.add_gridspec(1, 1, hspace=0.2, wspace=0.1, width_ratios=[3, ],
                              height_ratios=[1])
        # plot nb its
        gs1 = gs[0, 0].subgridspec(1, 2, wspace=0.1, width_ratios=[0.1, 5])
        ax = fig.add_subplot(gs1[0, 1])
        if phase_contrast == 1:
            nb_iterations = (nb_it_Jacobi_linear_1_e14[:, :])
        elif phase_contrast == 2:
            nb_iterations = (nb_it_Jacobi_linear_2_e06[:, :])

        elif phase_contrast == 4:
            # nb_iterations = (nb_it_Jacobi_linear_4_e14[:, :])
            nb_iterations = (nb_it_Jacobi_linear_4_e06[:, :])

        nb_iterations = np.nan_to_num(nb_iterations, nan=1.0)
        for i in range(nb_iterations.shape[0]):
            for j in range(nb_iterations.shape[1]):
                if nb_iterations[i, j] == 0:
                    pass
                elif nb_iterations[i, j] < 50:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}',
                            ha='center', va='center', color='black')
                else:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}',
                            ha='center', va='center', color='white')
        # divnorm = mpl.colors.LogNorm(vmin=1, vmax=100)
        divnorm = mpl.colors.Normalize(vmin=0, vmax=100)

        # Replace NaN values with zero

        pcm = ax.pcolormesh(X, Y, nb_iterations, label='PCG: Green + Jacobi', cmap='Reds', norm=divnorm)

        if geometry_ID == 'sine_wave_' and phase_contrast == 1:
            ax.text(0.05, 0.92, f'Total phase contrast \n' + r'$\kappa^^{\rm tot}=\infty$', transform=ax.transAxes)
        else:
            ax.text(0.05, 0.82, f'Total phase contrast \n $\kappa=10^{phase_contrast}$', transform=ax.transAxes)

        ax.set_title('Number of iteration \n Jacobi   ')
        # ax.set_zlim(1 ,100)
        ax.set_ylabel(r'\# of material phases')

        # ax.yaxis.set_label_position('right')
        # ax.yaxis.tick_right()
        ax.set_xlabel(r'\# of nodal points (x direction)')
        ax.set_xticks(Nx)
        ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
        # ax2 = ax.twinx()
        ax.set_yticks(Nx)
        ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
        ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
        # ax.set_aspect('equal')

        ax.text(-0.1, 1.09, '(a)', transform=ax.transAxes)

        fname = src + 'JG_exp4_GRID_DEP_nb_its{}_geom_{}_rhoJacobi{}{}'.format(geometry_ID, precc, phase_contrast,
                                                                               '.pdf')
        print(('create figure: {}'.format(fname)))
        plt.savefig(fname, bbox_inches='tight')

    plt.show()

#
plot_this = True
if plot_this:
    nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10]
    Nx = (np.asarray(nb_pix_multips))
    X, Y = np.meshgrid(Nx, Nx, indexing='ij')
    #
    #   nb_pix_multips = [2, 4, 5, 6, 7, 8]
    # material distribution
    geometry_ID = 'sine_wave_'  # linear  # 'abs_val' sine_wave_   ,laminate_log  geometry_ID = 'right_cluster_x3'  # laminate2       # 'abs_val' sine_wave_   ,laminate_log
    # rhs = 'sin_wave'
    rhs = False
    linestyles = ['-', '--', ':', '-.', '--', ':', '-.']
    colors = ['red', 'blue', 'green', 'orange', 'purple', 'orange', 'purple']
    precc = 6
    fig = plt.figure(figsize=(8.5, 5.5))  # 11, 7.0
    gs = fig.add_gridspec(2, 4, hspace=0.22, wspace=0.25, width_ratios=[1.2, 1.2, 1.2, 0.03],
                          height_ratios=[1, 1])
    row = 0
    for phase_contrast in [2, 4]:  # 1, 4
        ratio = phase_contrast
        if geometry_ID == 'linear':
            divnorm = mpl.colors.Normalize(vmin=0, vmax=100)
            white_lim = 50
        elif geometry_ID == 'sine_wave_':
            divnorm = mpl.colors.Normalize(vmin=0, vmax=100)
            white_lim = 50
        # Green graph
        gs0 = gs[row, 0].subgridspec(1, 1, wspace=0.1, width_ratios=[1])
        ax = fig.add_subplot(gs0[0, 0])
        # ax.set_aspect('equal')
        if phase_contrast == 1:
            if geometry_ID == 'sine_wave_rapid':
                nb_iterations = (nb_it_combi_laminate2_1[:, :])
            if geometry_ID == 'laminate2':
                nb_iterations = (nb_it_Green_laminate2_1[:, :])
            elif geometry_ID == 'linear':
                if precc == 14:
                    nb_iterations = (nb_it_Green_linear_1_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Green_linear_1_e06[:, :])
            elif geometry_ID == 'right_cluster_x3':
                if precc == 14:
                    nb_iterations = (nb_it_Green_right_cluster_x3_1_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Green_right_cluster_x3_1_e06[:, :])
            elif geometry_ID == 'left_cluster_x3':
                if precc == 14:
                    nb_iterations = (nb_it_Green_left_cluster_x3_1_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Green_left_cluster_x3_1_e06[:, :])
            elif geometry_ID == 'n_laminate':
                if precc == 14:
                    if rhs == 'sin_wave':
                        nb_iterations = (nb_it_Green_n_laminate_sinrhs_1_e14[:, :])
                    else:
                        nb_iterations = (nb_it_Green_n_laminate_1_e14[:, :])
                if precc == 6:
                    nb_iterations = (nb_it_Green_n_laminate_1_e06[:, :])


            elif geometry_ID == 'laminate_log':
                if precc == 14:
                    nb_iterations = (nb_it_Green_laminate_log_1_e14[:, :])
                if precc == 6:
                    nb_iterations = (nb_it_Green_laminate_log_1_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                nb_iterations = (nb_it_Green_sine_wave_0_e14[:, :])  # nb_it_combi_laminate2_1
        elif phase_contrast == 2:
            if geometry_ID == 'linear':
                if precc == 6:
                    nb_iterations = (nb_it_Green_linear_2_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                nb_iterations = nb_it_Green_sine_wave_0_e06[:, :]


        elif phase_contrast == 4:
            if geometry_ID == 'sine_wave_rapid':
                nb_iterations = (nb_it_combi_laminate2_1[:, :])
            if geometry_ID == 'laminate2':
                nb_iterations = (nb_it_Green_laminate2_4[:, :])
            elif geometry_ID == 'linear':
                if precc == 14:
                    nb_iterations = (nb_it_Green_linear_4_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Green_linear_4_e06[:, :])
            elif geometry_ID == 'right_cluster_x3':
                if precc == 14:
                    nb_iterations = (nb_it_Green_right_cluster_x3_4_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Green_right_cluster_x3_4_e06[:, :])
            elif geometry_ID == 'left_cluster_x3':
                if precc == 14:
                    nb_iterations = (nb_it_Green_left_cluster_x3_4_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Green_left_cluster_x3_4_e06[:, :])
            elif geometry_ID == 'n_laminate':
                if precc == 14:
                    if rhs == 'sin_wave':
                        nb_iterations = (nb_it_Green_n_laminate_sinrhs_4_e14[:, :])

                    else:
                        nb_iterations = (nb_it_Green_n_laminate_4_e14[:, :])
                if precc == 6:
                    nb_iterations = (nb_it_Green_n_laminate_4_e06[:, :])

            elif geometry_ID == 'laminate_log':
                if precc == 14:
                    nb_iterations = (nb_it_Green_laminate_log_4_e14[:, :])
                if precc == 6:
                    nb_iterations = (nb_it_Green_laminate_log_4_e06[:, :])

            elif geometry_ID == 'sine_wave_':
                if precc == 14:
                    nb_iterations = (nb_it_Green_sine_wave_4_e14[:, :])  # nb_it_combi_laminate2_1
                elif precc == 6:
                    nb_iterations = (nb_it_Green_sine_wave_4_e06[:, :])  # nb_it_combi_laminate2_1

        nb_iterations = np.nan_to_num(nb_iterations, nan=1.0)
        for i in range(nb_iterations.shape[0]):
            for j in range(nb_iterations.shape[1]):
                if nb_iterations[i, j] == 0:
                    pass
                elif nb_iterations[i, j] < white_lim:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='black')
                elif nb_iterations[i, j] > 999:
                    ax.text(i + Nx[0], j + Nx[0], f'{999:.0f}', size=8,
                            ha='center', va='center', color='black')
                else:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='white')

        pcm = ax.pcolormesh(X, Y, nb_iterations, label='PCG: Green + Jacobi', cmap='Reds', norm=divnorm)

        # ax.text(0.05, 0.92, f'Total phase contrast $\kappa=10^{phase_contrast}$', transform=ax.transAxes)
        if geometry_ID == 'sine_wave_' and phase_contrast == 2:
            ax.text(0.05, 0.82, f'Total phase contrast \n' + r'$\kappa^{\rm tot}=\infty$', transform=ax.transAxes)
        elif geometry_ID == 'sine_wave_':
            ax.text(0.05, 0.82, f'Total phase contrast \n' + fr' $\kappa^{{\rm tot}}=10^{{{phase_contrast}}}$',
                    transform=ax.transAxes)
        else:
            ax.text(0.05, 0.82, f'Total phase contrast \n' + fr' $\kappa^{{\rm tot}}=10^{{{phase_contrast}}}$',
                    transform=ax.transAxes)

        if row == 0:
            ax.set_title('Number of iterations \n Green ')
        # ax.set_zlim(1 ,100)
        # ax.set_ylabel('# data/geometry sampling points (x direction)')

        # ax.yaxis.set_label_position('right')
        # ax.yaxis.tick_right()
        ax.set_ylabel(r'\#  material pixels - $p$')#$p$~of~$\mathcal{G}_p$
        if row == 1:
            ax.set_xlabel(r'\#  nodal points - $n$')#~of~$\mathcal{T}_n$
        ax.set_xticks(Nx)
        ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
        # ax2 = ax.twinx()
        ax.set_yticks(Nx)
        ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
        ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
        #    ax.set_aspect('equal')
        if row == 0:
            ax.text(-0.25, 1.15, f'(a.{row + 1})', transform=ax.transAxes)
        elif row == 1:
            ax.text(-0.25, 1.05, f'(a.{row + 1})', transform=ax.transAxes)

        # jacobi  graph
        gs1 = gs[row, 1].subgridspec(1, 1, wspace=0.1, width_ratios=[5])
        ax = fig.add_subplot(gs1[0, 0])
        #    ax.set_aspect('equal')
        if phase_contrast == 1:
            if geometry_ID == 'linear':
                if precc == 14:
                    nb_iterations = (nb_it_Jacobi_linear_1_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Jacobi_linear_1_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                if precc == 14:
                    nb_iterations = (nb_it_Jacobi_sine_wave_0_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Jacobi_sine_wave_0_e06[:, :])
        if phase_contrast == 2:
            if geometry_ID == 'linear':
                if precc == 14:
                    quit()
                    # nb_iterations = (nb_it_Jacobi_linear_2_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Jacobi_linear_2_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                if precc == 14:
                    nb_iterations = (nb_it_Jacobi_sine_wave_0_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Jacobi_sine_wave_0_e06[:, :])

        elif phase_contrast == 4:
            if geometry_ID == 'linear':
                if precc == 14:
                    nb_iterations = (nb_it_Jacobi_linear_4_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Jacobi_linear_4_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                if precc == 14:
                    nb_iterations = (nb_it_Jacobi_sine_wave_4_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_Jacobi_sine_wave_4_e06[:, :])

        nb_iterations = np.nan_to_num(nb_iterations, nan=1.0)
        for i in range(nb_iterations.shape[0]):
            for j in range(nb_iterations.shape[1]):
                if nb_iterations[i, j] == 0:
                    pass
                elif nb_iterations[i, j] < white_lim:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='black')
                elif nb_iterations[i, j] > 999:
                    ax.text(i + Nx[0], j + Nx[0], f'{999:.0f}', size=8,
                            ha='center', va='center', color='white')
                else:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='white')

        pcm = ax.pcolormesh(X, Y, nb_iterations, label='PCG: Green + Jacobi', cmap='Reds', norm=divnorm)

        # ax.text(0.05, 0.92, f'Total phase contrast $\kappa=10^{phase_contrast}$', transform=ax.transAxes)
        if geometry_ID == 'sine_wave_' and phase_contrast == 2:
            ax.text(0.05, 0.82, f'Total phase contrast \n' + r'$\kappa^{\rm tot}=\infty$', transform=ax.transAxes)
        elif geometry_ID == 'sine_wave_':
            ax.text(0.05, 0.82, f'Total phase contrast \n' + fr' $\kappa^{{\rm tot}}=10^{{{phase_contrast}}}$',
                    transform=ax.transAxes)
        else:
            ax.text(0.05, 0.82, f'Total phase contrast \n' + fr' $\kappa^{{\rm tot}}=10^{{{phase_contrast}}}$',
                    transform=ax.transAxes)

        if row == 0:
            ax.set_title('Number of iterations \n Jacobi ')
        # ax.set_zlim(1 ,100)
        # ax.set_ylabel('# data/geometry sampling points (x direction)')

        # ax.yaxis.set_label_position('right')
        # ax.yaxis.tick_right()
        if row == 1:
            ax.set_xlabel(r'\#  nodal points - $n$')#~of~$\mathcal{T}_n$

        ax.set_xticks(Nx)
        ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
        # ax2 = ax.twinx()
        ax.set_yticks(Nx)
        ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
        ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
        #    ax.set_aspect('equal')

        # ax.set_zlabel('# CG iterations')
        if row == 0:
            ax.text(-0.17, 1.15, f'(b.{row + 1})', transform=ax.transAxes)
        elif row == 1:
            ax.text(-0.17, 1.05, f'(b.{row + 1})', transform=ax.transAxes)
        # plot Jacobi green
        gs2 = gs[row, 2].subgridspec(1, 1, wspace=0.1, width_ratios=[5])
        ax = fig.add_subplot(gs2[0, 0])
        if phase_contrast == 1:

            if geometry_ID == 'sine_wave_rapid':
                nb_iterations = (nb_it_combi_laminate2_1[:, :])
            if geometry_ID == 'laminate2':
                nb_iterations = (nb_it_combi_laminate2_1[:, :])
            elif geometry_ID == 'linear':
                if precc == 14:
                    nb_iterations = (nb_it_combi_linear_1_e14[:, :])
                if precc == 6:
                    nb_iterations = (nb_it_combi_linear_1_e06[:, :])
            elif geometry_ID == 'right_cluster_x3':
                if precc == 14:
                    nb_iterations = (nb_it_combi_right_cluster_x3_1_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_combi_right_cluster_x3_1_e06[:, :])
            elif geometry_ID == 'left_cluster_x3':
                if precc == 14:
                    nb_iterations = (nb_it_combi_left_cluster_x3_1_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_combi_left_cluster_x3_1_e06[:, :])
            elif geometry_ID == 'n_laminate':

                if precc == 14:
                    if rhs == 'sin_wave':
                        nb_iterations = (nb_it_combi_n_laminate_sinrhs_1_e14[:, :])
                    else:
                        nb_iterations = (nb_it_combi_n_laminate_1_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_combi_n_laminate_1_e06[:, :])


            elif geometry_ID == 'laminate_log':
                if precc == 14:
                    nb_iterations = (nb_it_combi_laminate_log_1_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_combi_laminate_log_1_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                nb_iterations = (nb_it_combi_sine_wave_0_e14[:, :])  # nb_it_combi_laminate2_1
        elif phase_contrast == 2:
            if geometry_ID == 'linear':
                if precc == 6:
                    nb_iterations = (nb_it_combi_linear_2_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                nb_iterations = nb_it_combi_sine_wave_0_e06[:, :]

        elif phase_contrast == 4:
            if geometry_ID == 'sine_wave_rapid':
                nb_iterations = (nb_it_combi_laminate2_1[:, :])
            if geometry_ID == 'laminate2':
                nb_iterations = (nb_it_combi_laminate2_4[:, :])
            elif geometry_ID == 'linear':
                if precc == 14:
                    nb_iterations = (nb_it_combi_linear_4_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_combi_linear_4_e06[:, :])

            elif geometry_ID == 'right_cluster_x3':
                if precc == 14:
                    nb_iterations = (nb_it_combi_right_cluster_x3_4_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_combi_right_cluster_x3_4_e06[:, :])
            elif geometry_ID == 'left_cluster_x3':
                if precc == 14:
                    nb_iterations = (nb_it_combi_left_cluster_x3_4_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_combi_left_cluster_x3_4_e06[:, :])
            elif geometry_ID == 'n_laminate':
                if precc == 14:
                    if rhs == 'sin_wave':
                        nb_iterations = (nb_it_combi_n_laminate_sinrhs_4_e14[:, :])
                    else:
                        nb_iterations = (nb_it_combi_n_laminate_4_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_combi_n_laminate_4_e06[:, :])

            elif geometry_ID == 'laminate_log':
                if precc == 14:
                    nb_iterations = (nb_it_combi_laminate_log_4_e14[:, :])
                elif precc == 6:
                    nb_iterations = (nb_it_combi_laminate_log_4_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                if precc == 14:
                    nb_iterations = (nb_it_combi_sine_wave_4_e14[:, :])  # nb_it_combi_laminate2_1
                elif precc == 6:
                    nb_iterations = (nb_it_combi_sine_wave_4_e06[:, :])

        nb_iterations = np.nan_to_num(nb_iterations, nan=1.0)
        for i in range(nb_iterations.shape[0]):
            for j in range(nb_iterations.shape[1]):
                if nb_iterations[i, j] == 0:
                    pass
                elif nb_iterations[i, j] < white_lim:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='black')
                else:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='white')
        # Replace NaN values with zero

        pcm = ax.pcolormesh(X, Y, nb_iterations, label='PCG: Green + Jacobi', cmap='Reds', norm=divnorm)

        if geometry_ID == 'sine_wave_' and phase_contrast == 2:
            ax.text(0.05, 0.82, f'Total phase contrast \n' + r'$\kappa^{\rm tot}=\infty$', transform=ax.transAxes)
        elif geometry_ID == 'sine_wave_':
            ax.text(0.05, 0.82, f'Total phase contrast \n ' + fr' $\kappa^{{\rm tot}}=10^{{{phase_contrast}}}$',
                    transform=ax.transAxes)
        else:
            ax.text(0.05, 0.82, f'Total phase contrast \n' + fr' $\kappa^{{\rm tot}}=10^{{{phase_contrast}}}$',
                    transform=ax.transAxes)

        if row == 0:
            ax.set_title('Number of iterations \n Green-Jacobi')
        # ax.set_zlim(1 ,100)
        # ax.set_ylabel('# of material phases')

        # ax.yaxis.set_label_position('right')
        # ax.yaxis.tick_right()
        if row == 1:
            ax.set_xlabel(r'\#  nodal points - $n$')#~of~$\mathcal{T}_n$

        ax.set_xticks(Nx)
        ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
        # ax2 = ax.twinx()
        ax.set_yticks(Nx)
        ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
        ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
        #   ax.set_aspect('equal')

        if row == 0:
            ax.text(-0.17, 1.15, f'(c.{row + 1})', transform=ax.transAxes)
        elif row == 1:
            ax.text(-0.17, 1.05, f'(c.{row + 1})', transform=ax.transAxes)
        # Adding a color bar with custom ticks and labels
        cbar_ax = fig.add_subplot(gs[row, 3])
        cbar = plt.colorbar(pcm, location='left', cax=cbar_ax, ticklocation='right')  # Specify the ticks
        # cbar.ax.invert_yaxis()
        # # cbar.set_ticks(ticks=[  0, 1,10])
        # cbar.set_ticks([10, 5, 2, 1, 1 / 2, 1 / 5, 1 / 10])
        # cbar.ax.set_yticklabels(
        #     ['Jacobi-Green \n needs less', '5 times', '2 times', 'Equal', '2 times', '5 times',
        #      'Jacobi-Green \n needs more'])

        #

        row += 1

    fname = src + 'JG_exp4_GRID_DEP_nb_its{}_geom_{}_rho_v2_{}{}'.format(geometry_ID, precc, phase_contrast, '.pdf')
    print(('create figure: {}'.format(fname)))
    plt.savefig(fname, bbox_inches='tight')

plt.show()
quit()
nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10]
Nx = (np.asarray(nb_pix_multips))
X, Y = np.meshgrid(Nx, Nx, indexing='ij')

# material distribution
for geometry_ID in ['linear', 'sine_wave_']:  # linear

    # rhs = 'sin_wave'
    rhs = False
    linestyles = ['-', '--', ':', '-.', '--', ':', '-.']
    colors = ['red', 'blue', 'green', 'orange', 'purple', 'orange', 'purple']
    precc = 6

    row = 0
    for phase_contrast in [2, 4]:  # 1, 4
        ratio = phase_contrast
        fig = plt.figure(figsize=(8, 3.5))
        gs = fig.add_gridspec(1, 3, hspace=0.2, wspace=0.25, width_ratios=[1.2, 1.2, 0.03],
                              height_ratios=[1])
        if geometry_ID == 'linear':
            divnorm = mpl.colors.Normalize(vmin=0, vmax=100)
            white_lim = 50
        elif geometry_ID == 'sine_wave_':
            divnorm = mpl.colors.Normalize(vmin=0, vmax=100)
            white_lim = 50
        # Green graph
        gs0 = gs[row, 0].subgridspec(1, 1, wspace=0.1, width_ratios=[1])
        ax = fig.add_subplot(gs0[0, 0])
        # ax.set_aspect('equal')
        if phase_contrast == 2:
            if geometry_ID == 'linear':
                if precc == 6:
                    nb_iterations = (nb_it_Green_linear_2_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                if precc == 6:
                    nb_iterations = nb_it_Green_sine_wave_0_e06[:, :]
        elif phase_contrast == 4:
            if geometry_ID == 'linear':
                if precc == 6:
                    nb_iterations = nb_it_Green_linear_4_e06[:, :]
            elif geometry_ID == 'sine_wave_':
                if precc == 6:
                    nb_iterations = (nb_it_Green_sine_wave_4_e06[:, :])

        nb_iterations = np.nan_to_num(nb_iterations, nan=1.0)
        for i in range(nb_iterations.shape[0]):
            for j in range(nb_iterations.shape[1]):
                if nb_iterations[i, j] == 0:
                    pass
                elif nb_iterations[i, j] < white_lim:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='black')
                else:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='white')

        pcm = ax.pcolormesh(X, Y, nb_iterations, label='PCG: Green + Jacobi', cmap='Reds', norm=divnorm)

        # ax.text(0.05, 0.92, f'Total phase contrast $\kappa=10^{phase_contrast}$', transform=ax.transAxes)
        if geometry_ID == 'sine_wave_' and phase_contrast == 2:
            ax.text(0.05, 0.82, f'Total phase contrast \n' + r'$\kappa=\infty$', transform=ax.transAxes)
        elif geometry_ID == 'sine_wave_':
            ax.text(0.05, 0.82, f'Total phase contrast \n $\kappa=10^{{{-phase_contrast}}}$', transform=ax.transAxes)
        else:
            ax.text(0.05, 0.82, f'Total phase contrast \n $\kappa=10^{phase_contrast}$', transform=ax.transAxes)

        if row == 0:
            ax.set_title('Total number of iteration \n Green ')
        # ax.set_zlim(1 ,100)
        # ax.set_ylabel('# data/geometry sampling points (x direction)')

        # ax.yaxis.set_label_position('right')
        # ax.yaxis.tick_right()
        ax.set_ylabel(r'\#  material pixels')
        ax.set_xlabel(r'\#  nodal points (x direction)')
        ax.set_xticks(Nx)
        ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
        # ax2 = ax.twinx()
        ax.set_yticks(Nx)
        ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
        ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)

        # plot Jacobi green
        gs2 = gs[row, 1].subgridspec(1, 1, wspace=0.1, width_ratios=[5])
        ax = fig.add_subplot(gs2[0, 0])
        if phase_contrast == 2:
            if geometry_ID == 'linear':
                if precc == 6:
                    nb_iterations = (nb_it_combi_linear_2_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                if precc == 6:
                    nb_iterations = nb_it_combi_sine_wave_0_e06[:, :]
        elif phase_contrast == 4:
            if geometry_ID == 'linear':
                if precc == 6:
                    nb_iterations = nb_it_combi_linear_4_e06[:, :]
            elif geometry_ID == 'sine_wave_':
                if precc == 6:
                    nb_iterations = (nb_it_combi_sine_wave_4_e06[:, :])
        nb_iterations = np.nan_to_num(nb_iterations, nan=1.0)
        for i in range(nb_iterations.shape[0]):
            for j in range(nb_iterations.shape[1]):
                if nb_iterations[i, j] == 0:
                    pass
                elif nb_iterations[i, j] < white_lim:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='black')
                else:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='white')
        # Replace NaN values with zero

        pcm = ax.pcolormesh(X, Y, nb_iterations, label='PCG: Green + Jacobi', cmap='Reds', norm=divnorm)

        if geometry_ID == 'sine_wave_' and phase_contrast == 2:
            ax.text(0.05, 0.82, f'Total phase contrast \n' + r'$\kappa=\infty$', transform=ax.transAxes)
        elif geometry_ID == 'sine_wave_':
            ax.text(0.05, 0.82, f'Total phase contrast \n $\kappa=10^{{{-phase_contrast}}}$', transform=ax.transAxes)
        else:
            ax.text(0.05, 0.82, f'Total phase contrast \n  $\kappa=10^{phase_contrast}$', transform=ax.transAxes)

        if row == 0:
            ax.set_title('Total number of iteration \n Jacobi-Green  ')
        # ax.set_zlim(1 ,100)
        # ax.set_ylabel('# of material phases')

        # ax.yaxis.set_label_position('right')
        # ax.yaxis.tick_right()
        ax.set_xlabel(r'\# of nodal points (x direction)')
        ax.set_xticks(Nx)
        ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
        # ax2 = ax.twinx()
        ax.set_yticks(Nx)
        ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
        ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
        #   ax.set_aspect('equal')

        # Adding a color bar with custom ticks and labels
        cbar_ax = fig.add_subplot(gs[row, 2])
        cbar = plt.colorbar(pcm, location='left', cax=cbar_ax, ticklocation='right')  # Specify the ticks
        # cbar.ax.invert_yaxis()
        # # cbar.set_ticks(ticks=[  0, 1,10])
        # cbar.set_ticks([10, 5, 2, 1, 1 / 2, 1 / 5, 1 / 10])
        # cbar.ax.set_yticklabels(
        #     ['Jacobi-Green \n needs less', '5 times', '2 times', 'Equal', '2 times', '5 times',
        #      'Jacobi-Green \n needs more'])

        #

        fname = src + 'JG_exp_tables_zero_x0_{}_geom_{}_rho_{}_contrast{}'.format(geometry_ID, precc, phase_contrast,
                                                                                  '.pdf')
        print(('create figure: {}'.format(fname)))
        plt.savefig(fname, bbox_inches='tight')

    plt.show()
nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10]
Nx = (np.asarray(nb_pix_multips))
X, Y = np.meshgrid(Nx, Nx, indexing='ij')

# material distribution
for geometry_ID in ['linear', 'sine_wave_']:  # linear

    # rhs = 'sin_wave'
    rhs = False
    linestyles = ['-', '--', ':', '-.', '--', ':', '-.']
    colors = ['red', 'blue', 'green', 'orange', 'purple', 'orange', 'purple']
    precc = 6

    row = 0
    for phase_contrast in [2, 4]:  # 1, 4
        ratio = phase_contrast
        fig = plt.figure(figsize=(4, 3.5))
        gs = fig.add_gridspec(1, 2, hspace=0.2, wspace=0.25, width_ratios=[1.2, 0.03],
                              height_ratios=[1])
        if geometry_ID == 'linear':
            divnorm = mpl.colors.Normalize(vmin=0, vmax=100)
            white_lim = 50
        elif geometry_ID == 'sine_wave_':
            divnorm = mpl.colors.Normalize(vmin=0, vmax=100)
            white_lim = 50
        # Green graph
        gs0 = gs[row, 0].subgridspec(1, 1, wspace=0.1, width_ratios=[1])
        ax = fig.add_subplot(gs0[0, 0])
        # ax.set_aspect('equal')
        if phase_contrast == 2:
            if geometry_ID == 'linear':
                if precc == 6:
                    nb_iterations = (nb_it_Green_linear_2_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                if precc == 6:
                    nb_iterations = nb_it_Green_sine_wave_0_e06[:, :]
        elif phase_contrast == 4:
            if geometry_ID == 'linear':
                if precc == 6:
                    nb_iterations = nb_it_Green_linear_4_e06[:, :]
            elif geometry_ID == 'sine_wave_':
                if precc == 6:
                    nb_iterations = (nb_it_Green_sine_wave_4_e06[:, :])

        nb_iterations = np.nan_to_num(nb_iterations, nan=1.0)
        for i in range(nb_iterations.shape[0]):
            for j in range(nb_iterations.shape[1]):
                if nb_iterations[i, j] == 0:
                    pass
                elif nb_iterations[i, j] < white_lim:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='black')
                else:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='white')

        pcm = ax.pcolormesh(X, Y, nb_iterations, label='PCG: Green + Jacobi', cmap='Reds', norm=divnorm)

        # ax.text(0.05, 0.92, f'Total phase contrast $\kappa=10^{phase_contrast}$', transform=ax.transAxes)
        if geometry_ID == 'sine_wave_' and phase_contrast == 2:
            ax.text(0.05, 0.82, f'Total phase contrast \n' + r'$\kappa=\infty$', transform=ax.transAxes)
        elif geometry_ID == 'sine_wave_':
            ax.text(0.05, 0.82, f'Total phase contrast \n $\kappa=10^{{{-phase_contrast}}}$', transform=ax.transAxes)
        else:
            ax.text(0.05, 0.82, f'Total phase contrast \n $\kappa=10^{phase_contrast}$', transform=ax.transAxes)

        if row == 0:
            ax.set_title('Total number of iteration \n Green ')
        # ax.set_zlim(1 ,100)
        # ax.set_ylabel('# data/geometry sampling points (x direction)')

        # ax.yaxis.set_label_position('right')
        # ax.yaxis.tick_right()
        ax.set_ylabel(r'\# of material phases')
        ax.set_xlabel(r'\# of nodal points (x direction)')
        ax.set_xticks(Nx)
        ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
        # ax2 = ax.twinx()
        ax.set_yticks(Nx)
        ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
        ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
        # Adding a color bar with custom ticks and labels
        cbar_ax = fig.add_subplot(gs[row, 1])
        cbar = plt.colorbar(pcm, location='left', cax=cbar_ax, ticklocation='right')  # Specify the ticks

        fname = src + 'JG_exp_tables_Green_zero_x0_{}_geom_{}_rho_{}_contrast{}'.format(geometry_ID, precc,
                                                                                        phase_contrast,
                                                                                        '.pdf')
        print(('create figure: {}'.format(fname)))
        plt.savefig(fname, bbox_inches='tight')

        # plot Jacobi green
        fig = plt.figure(figsize=(4, 3.5))
        gs = fig.add_gridspec(1, 2, hspace=0.2, wspace=0.25, width_ratios=[1.2, 0.03],
                              height_ratios=[1])
        gs2 = gs[row, 0].subgridspec(1, 1, wspace=0.1, width_ratios=[5])
        ax = fig.add_subplot(gs2[0, 0])
        if phase_contrast == 2:
            if geometry_ID == 'linear':
                if precc == 6:
                    nb_iterations = (nb_it_combi_linear_2_e06[:, :])
            elif geometry_ID == 'sine_wave_':
                if precc == 6:
                    nb_iterations = nb_it_combi_sine_wave_0_e06[:, :]
        elif phase_contrast == 4:
            if geometry_ID == 'linear':
                if precc == 6:
                    nb_iterations = nb_it_combi_linear_4_e06[:, :]
            elif geometry_ID == 'sine_wave_':
                if precc == 6:
                    nb_iterations = (nb_it_combi_sine_wave_4_e06[:, :])
        nb_iterations = np.nan_to_num(nb_iterations, nan=1.0)
        for i in range(nb_iterations.shape[0]):
            for j in range(nb_iterations.shape[1]):
                if nb_iterations[i, j] == 0:
                    pass
                elif nb_iterations[i, j] < white_lim:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='black')
                else:
                    ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}', size=8,
                            ha='center', va='center', color='white')
        # Replace NaN values with zero

        pcm = ax.pcolormesh(X, Y, nb_iterations, label='PCG: Green + Jacobi', cmap='Reds', norm=divnorm)

        if geometry_ID == 'sine_wave_' and phase_contrast == 2:
            ax.text(0.05, 0.82, f'Total phase contrast \n' + r'$\kappa=\infty$', transform=ax.transAxes)
        elif geometry_ID == 'sine_wave_':
            ax.text(0.05, 0.82, f'Total phase contrast \n $\kappa=10^{{{-phase_contrast}}}$', transform=ax.transAxes)
        else:
            ax.text(0.05, 0.82, f'Total phase contrast \n  $\kappa=10^{phase_contrast}$', transform=ax.transAxes)

        if row == 0:
            ax.set_title('Total number of iteration \n Jacobi-Green  ')
        # ax.set_zlim(1 ,100)
        # ax.set_ylabel('# of material phases')

        # ax.yaxis.set_label_position('right')
        # ax.yaxis.tick_right()
        ax.set_xlabel(r'\# of nodal points (x direction)')
        ax.set_xticks(Nx)
        ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
        # ax2 = ax.twinx()
        ax.set_yticks(Nx)
        ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
        ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
        #   ax.set_aspect('equal')

        # Adding a color bar with custom ticks and labels
        cbar_ax = fig.add_subplot(gs[row, 1])
        cbar = plt.colorbar(pcm, location='left', cax=cbar_ax, ticklocation='right')  # Specify the ticks
        # cbar.ax.invert_yaxis()
        # # cbar.set_ticks(ticks=[  0, 1,10])
        # cbar.set_ticks([10, 5, 2, 1, 1 / 2, 1 / 5, 1 / 10])
        # cbar.ax.set_yticklabels(
        #     ['Jacobi-Green \n needs less', '5 times', '2 times', 'Equal', '2 times', '5 times',
        #      'Jacobi-Green \n needs more'])

        #

        fname = src + 'JG_exp_tables_Jacobi_zero_x0_{}_geom_{}_rho_{}_contrast{}'.format(geometry_ID, precc,
                                                                                         phase_contrast,
                                                                                         '.pdf')
        print(('create figure: {}'.format(fname)))
        plt.savefig(fname, bbox_inches='tight')

    plt.show()
quit()

#
nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10]
Nx = (np.asarray(nb_pix_multips))
X, Y = np.meshgrid(Nx, Nx, indexing='ij')

nb_pix_multips = [2, 4, 10]
# material distribution
geometry_ID = 'sine_wave_'  # laminate2  sine_wave_rapid     # 'abs_val' sine_wave_   ,laminate_log  geometry_ID = 'right_cluster_x3'  # laminate2       # 'abs_val' sine_wave_   ,laminate_log
# rhs = 'sin_wave'
rhs = False
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']
precc = 14
for phase_contrast in [1, 4]:
    ratio = phase_contrast
    fig = plt.figure(figsize=(11, 3.5))
    gs = fig.add_gridspec(1, 3, hspace=0.2, wspace=0.1, width_ratios=[3, 3, 3],
                          height_ratios=[1])
    # rigth subplots
    gs2 = gs[0, 1].subgridspec(3, 2, hspace=0.1, wspace=0.2, width_ratios=[1, 1], height_ratios=[1, 1, 1])
    # plot nb its
    gs1 = gs[0, 0].subgridspec(1, 2, wspace=0.1, width_ratios=[0.1, 5])
    ax = fig.add_subplot(gs1[0, 1])
    if phase_contrast == 1:

        if geometry_ID == 'sine_wave_rapid':
            nb_iterations = (nb_it_combi_laminate2_1[:, :])
        if geometry_ID == 'laminate2':
            nb_iterations = (nb_it_combi_laminate2_1[:, :])
        elif geometry_ID == 'linear':
            if precc == 14:
                nb_iterations = (nb_it_combi_linear_1_e14[:, :])
        elif geometry_ID == 'right_cluster_x3':
            if precc == 14:
                nb_iterations = (nb_it_combi_right_cluster_x3_1_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_combi_right_cluster_x3_1_e06[:, :])
        elif geometry_ID == 'left_cluster_x3':
            if precc == 14:
                nb_iterations = (nb_it_combi_left_cluster_x3_1_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_combi_left_cluster_x3_1_e06[:, :])
        elif geometry_ID == 'n_laminate':

            if precc == 14:
                if rhs == 'sin_wave':
                    nb_iterations = (nb_it_combi_n_laminate_sinrhs_1_e14[:, :])
                else:
                    nb_iterations = (nb_it_combi_n_laminate_1_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_combi_n_laminate_1_e06[:, :])


        elif geometry_ID == 'laminate_log':
            if precc == 14:
                nb_iterations = (nb_it_combi_laminate_log_1_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_combi_laminate_log_1_e06[:, :])
        elif geometry_ID == 'sine_wave_':
            nb_iterations = (nb_it_combi_sine_wave_0_e14[:, :])  # nb_it_combi_laminate2_1
    elif phase_contrast == 4:
        if geometry_ID == 'sine_wave_rapid':
            nb_iterations = (nb_it_combi_laminate2_1[:, :])
        if geometry_ID == 'laminate2':
            nb_iterations = (nb_it_combi_laminate2_4[:, :])
        elif geometry_ID == 'linear':
            if precc == 14:
                nb_iterations = (nb_it_combi_linear_4_e14[:, :])
        elif geometry_ID == 'right_cluster_x3':
            if precc == 14:
                nb_iterations = (nb_it_combi_right_cluster_x3_4_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_combi_right_cluster_x3_4_e06[:, :])
        elif geometry_ID == 'left_cluster_x3':
            if precc == 14:
                nb_iterations = (nb_it_combi_left_cluster_x3_4_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_combi_left_cluster_x3_4_e06[:, :])
        elif geometry_ID == 'n_laminate':
            if precc == 14:
                if rhs == 'sin_wave':
                    nb_iterations = (nb_it_combi_n_laminate_sinrhs_4_e14[:, :])
                else:
                    nb_iterations = (nb_it_combi_n_laminate_4_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_combi_n_laminate_4_e06[:, :])

        elif geometry_ID == 'laminate_log':
            if precc == 14:
                nb_iterations = (nb_it_combi_laminate_log_4_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_combi_laminate_log_4_e06[:, :])
        elif geometry_ID == 'sine_wave_':
            nb_iterations = (nb_it_combi_sine_wave_4_e14[:, :])  # nb_it_combi_laminate2_1

    nb_iterations = np.nan_to_num(nb_iterations, nan=1.0)
    for i in range(nb_iterations.shape[0]):
        for j in range(nb_iterations.shape[1]):
            if nb_iterations[i, j] == 0:
                pass
            elif nb_iterations[i, j] < 50:
                ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}',
                        ha='center', va='center', color='black')
            else:
                ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}',
                        ha='center', va='center', color='white')
    # divnorm = mpl.colors.LogNorm(vmin=1, vmax=100)
    divnorm = mpl.colors.Normalize(vmin=0, vmax=100)

    # Replace NaN values with zero

    pcm = ax.pcolormesh(X, Y, nb_iterations, label='PCG: Green + Jacobi', cmap='Reds', norm=divnorm)

    if geometry_ID == 'sine_wave_' and phase_contrast == 1:
        ax.text(0.05, 0.92, r'Total phase contrast $\kappa=\infty$', transform=ax.transAxes)
    else:
        ax.text(0.05, 0.92, f'Total phase contrast $\kappa=10^{phase_contrast}$', transform=ax.transAxes)

    ax.set_title('Total number of iteration \n Jacobi-Green  ')
    # ax.set_zlim(1 ,100)
    ax.set_ylabel(r'\# of material phases')

    # ax.yaxis.set_label_position('right')
    # ax.yaxis.tick_right()
    ax.set_xlabel(r'\# of nodal points (x direction)')
    ax.set_xticks(Nx)
    ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
    # ax2 = ax.twinx()
    ax.set_yticks(Nx)
    ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
    ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
    ax.set_aspect('equal')

    # cbar_ax = fig.add_subplot(gs1[0, 0])

    # cbar = plt.colorbar(pcm, location='left', cax=cbar_ax)  # Specify the ticks
    # cbar.ax.invert_yaxis()
    # # cbar.set_ticks(ticks=[  0, 1,10])
    # cbar.set_ticks([0, 50, 100])
    # cbar.ax.set_yticklabels(
    #     ['Jacobi-Green \n needs less', '5 times', '2 times', 'Equal', '2 times', '5 times',
    #      'Jacobi-Green \n needs more'])
    ax.annotate(text='',
                xy=(1.15, 0.15), xycoords='axes fraction',  # endpoint
                xytext=(1.01, 0.05),  # Start point
                arrowprops=dict(arrowstyle='-',
                                color='black',
                                lw=1,
                                ls='-')
                )

    # arrow 1
    ax.annotate(text='',
                xy=(1.15, 0.55),
                xycoords='axes fraction',
                xytext=(1.01, 0.28),
                arrowprops=dict(arrowstyle='-',
                                color='black',
                                lw=1,
                                ls='-')
                )
    # arrow 2
    ax.annotate(text='',
                xy=(1.15, 0.83), xycoords='axes fraction',
                xytext=(1.01, 0.95),
                arrowprops=dict(arrowstyle='-',
                                color='black',
                                lw=1,
                                ls='-')
                )
    ax.text(-0.1, 1.09, '(a)', transform=ax.transAxes)

    # right graph
    gs3 = gs[0, 2].subgridspec(1, 2, wspace=0.1, width_ratios=[5, 0.2])
    ax = fig.add_subplot(gs3[0, 0])
    ax.set_aspect('equal')
    if phase_contrast == 1:
        if geometry_ID == 'sine_wave_rapid':
            nb_iterations = (nb_it_combi_laminate2_1[:, :])
        if geometry_ID == 'laminate2':
            nb_iterations = (nb_it_Green_laminate2_1[:, :])
        elif geometry_ID == 'linear':
            if precc == 14:
                nb_iterations = (nb_it_Green_linear_1_e14[:, :])
        elif geometry_ID == 'right_cluster_x3':
            if precc == 14:
                nb_iterations = (nb_it_Green_right_cluster_x3_1_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_Green_right_cluster_x3_1_e06[:, :])
        elif geometry_ID == 'left_cluster_x3':
            if precc == 14:
                nb_iterations = (nb_it_Green_left_cluster_x3_1_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_Green_left_cluster_x3_1_e06[:, :])
        elif geometry_ID == 'n_laminate':
            if precc == 14:
                if rhs == 'sin_wave':
                    nb_iterations = (nb_it_Green_n_laminate_sinrhs_1_e14[:, :])
                else:
                    nb_iterations = (nb_it_Green_n_laminate_1_e14[:, :])
            if precc == 6:
                nb_iterations = (nb_it_Green_n_laminate_1_e06[:, :])


        elif geometry_ID == 'laminate_log':
            if precc == 14:
                nb_iterations = (nb_it_Green_laminate_log_1_e14[:, :])
            if precc == 6:
                nb_iterations = (nb_it_Green_laminate_log_1_e06[:, :])
        elif geometry_ID == 'sine_wave_':
            nb_iterations = (nb_it_Green_sine_wave_0_e14[:, :])  # nb_it_combi_laminate2_1
    elif phase_contrast == 4:
        if geometry_ID == 'sine_wave_rapid':
            nb_iterations = (nb_it_combi_laminate2_1[:, :])
        if geometry_ID == 'laminate2':
            nb_iterations = (nb_it_Green_laminate2_4[:, :])
        elif geometry_ID == 'linear':
            if precc == 14:
                nb_iterations = (nb_it_Green_linear_4_e14[:, :])
        elif geometry_ID == 'right_cluster_x3':
            if precc == 14:
                nb_iterations = (nb_it_Green_right_cluster_x3_4_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_Green_right_cluster_x3_4_e06[:, :])
        elif geometry_ID == 'left_cluster_x3':
            if precc == 14:
                nb_iterations = (nb_it_Green_left_cluster_x3_4_e14[:, :])
            elif precc == 6:
                nb_iterations = (nb_it_Green_left_cluster_x3_4_e06[:, :])
        elif geometry_ID == 'n_laminate':
            if precc == 14:
                if rhs == 'sin_wave':
                    nb_iterations = (nb_it_Green_n_laminate_sinrhs_4_e14[:, :])

                else:
                    nb_iterations = (nb_it_Green_n_laminate_4_e14[:, :])
            if precc == 6:
                nb_iterations = (nb_it_Green_n_laminate_4_e06[:, :])

        elif geometry_ID == 'laminate_log':
            if precc == 14:
                nb_iterations = (nb_it_Green_laminate_log_4_e14[:, :])
            if precc == 6:
                nb_iterations = (nb_it_Green_laminate_log_4_e06[:, :])

        elif geometry_ID == 'sine_wave_':
            nb_iterations = (nb_it_Green_sine_wave_4_e14[:, :])  # nb_it_combi_laminate2_1
    nb_iterations = np.nan_to_num(nb_iterations, nan=1.0)
    for i in range(nb_iterations.shape[0]):
        for j in range(nb_iterations.shape[1]):
            if nb_iterations[i, j] == 0:
                pass
            elif nb_iterations[i, j] < 50:
                ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}',
                        ha='center', va='center', color='black')
            else:
                ax.text(i + Nx[0], j + Nx[0], f'{nb_iterations[i, j]:.0f}',
                        ha='center', va='center', color='white')

    pcm = ax.pcolormesh(X, Y, nb_iterations, label='PCG: Green + Jacobi', cmap='Reds', norm=divnorm)

    # ax.text(0.05, 0.92, f'Total phase contrast $\kappa=10^{phase_contrast}$', transform=ax.transAxes)
    if geometry_ID == 'sine_wave_' and phase_contrast == 1:
        ax.text(0.05, 0.92, r'Total phase contrast $\kappa=\infty$', transform=ax.transAxes)
    else:
        ax.text(0.05, 0.92, f'Total phase contrast $\kappa=10^{phase_contrast}$', transform=ax.transAxes)

    ax.set_title('Total number of iteration \n Green ')
    # ax.set_zlim(1 ,100)
    # ax.set_ylabel('# data/geometry sampling points (x direction)')

    # ax.yaxis.set_label_position('right')
    # ax.yaxis.tick_right()
    ax.set_xlabel(r'\# of nodal points (x direction)')
    ax.set_xticks(Nx)
    ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
    # ax2 = ax.twinx()
    ax.set_yticks(Nx)
    ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
    ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
    # Adding a color bar with custom ticks and labels
    cbar_ax = fig.add_subplot(gs3[0, 1])

    cbar = plt.colorbar(pcm, location='left', cax=cbar_ax, ticklocation='right')  # Specify the ticks
    # cbar.ax.invert_yaxis()
    # # cbar.set_ticks(ticks=[  0, 1,10])
    # cbar.set_ticks([10, 5, 2, 1, 1 / 2, 1 / 5, 1 / 10])
    # cbar.ax.set_yticklabels(
    #     ['Jacobi-Green \n needs less', '5 times', '2 times', 'Equal', '2 times', '5 times',
    #      'Jacobi-Green \n needs more'])

    # ax.set_zlabel('# CG iterations')
    ax.text(-0.1, 1.09, '(d)', transform=ax.transAxes)
    #
    counter = 0
    for kk in np.arange(np.size(nb_pix_multips)):
        nb_pix_multip = nb_pix_multips[kk]
        print(f'kk = {kk}')
        print(f'nb_pix_multip = {nb_pix_multip}')
        # system set up
        number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

        my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                          problem_type=problem_type)

        discretization = domain.Discretization(cell=my_cell,
                                               nb_of_pixels_global=number_of_pixels,
                                               discretization_type=discretization_type,
                                               element_type=element_type)

        # if kk == 0:
        if geometry_ID == 'laminate_log' or geometry_ID == 'n_laminate':
            phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                              microstructure_name=geometry_ID,
                                                              coordinates=discretization.fft.coords,
                                                              seed=1,
                                                              parameter=number_of_pixels[0],
                                                              contrast=-ratio
                                                              )
        else:
            phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                              microstructure_name=geometry_ID,
                                                              coordinates=discretization.fft.coords,
                                                              seed=1,
                                                              parameter=number_of_pixels[0],
                                                              contrast=1 / 10 ** ratio
                                                              )

        if geometry_ID == 'sine_wave_' or geometry_ID == 'left_cluster_x3' or geometry_ID == 'right_cluster_x3' or geometry_ID == 'linear':
            if geometry_ID == 'sine_wave_' and phase_contrast == 1:
                pass
            else:
                phase_field += 1 / 10 ** ratio
                phase_field = scale_field(phase_field, min_val=1 / 10 ** ratio, max_val=1.0)
        # phase_fied_small_grid=np.copy(phase_field_smooth)
        phase_field = np.copy(phase_field)

        x = np.arange(0, 1 * number_of_pixels[0])
        y = np.arange(0, 1 * number_of_pixels[1])
        X_, Y_ = np.meshgrid(x, y)

        print(f'kk = {kk}')

        ax0 = fig.add_subplot(gs2[2 - kk, 0])
        ax0.pcolormesh(X_, Y_, np.transpose(phase_field),
                       cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                       rasterized=True)
        # ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
        #           linestyle=linestyles[counter], linewidth=1.)
        # ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
        extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
        # extended_y = np.append(np.diag(phase_field), np.diag(phase_field)[-1])
        extended_y = np.append(phase_field[:, phase_field.shape[0] // 2],
                               phase_field[:, phase_field.shape[0] // 2][-1])
        # ax0.plot([-0.5, number_of_pixels[0] - 0.5], [-0.5, number_of_pixels[1] - 0.5], color=colors[counter],
        #          linestyle=linestyles[counter], linewidth=1., transform=ax0.transAxes)
        ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
                   linestyle=linestyles[counter], linewidth=1.)
        ax0.set_xticks([])
        ax0.set_yticks([])
        ax0.set_aspect('equal')
        if kk == 0:
            ax0.set_xlabel('x coordinate')
        if kk == 2:
            ax0.set_title(f'Phase' + r' $\rho$')

            ax0.text(-0.1, 1.3, '(b)', transform=ax0.transAxes)
        ax1 = fig.add_subplot(gs2[2 - kk, 1])

        ax1.step(extended_x, extended_y
                 , where='post',
                 linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
                 label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
        # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
        ax1.set_ylim([1 / 10 ** ratio - 0.5 / 10 ** ratio, 1.1])
        ax1.set_xlim([0, 1])
        ax1.set_xticks([])
        ax1.set_xticklabels([])

        # ax1.set_yticks([1 / 10 ** ratio, 0.50, 1.0001])
        # ax1.set_yticklabels([1 / 10 ** ratio, 0.50, 1.00])
        ax1.set_yticks([])
        ax1.set_yticklabels([])

        ax1.yaxis.set_label_position('left')
        ax1.yaxis.tick_left()
        ax1.set_xticks([])
        ax1.set_xticklabels([])

        if geometry_ID == 'sine_wave_' and phase_contrast == 1:
            ax1.set_yticks([0, 0.5, 1])
            # ax_2.set_yticklabels([1e-4, 0.5, 1])
            ax1.set_yticklabels([0, 0.5, 1])
        else:
            ax1.set_yticks([1 / 10 ** ratio, 0.5, 1])
            # ax_2.set_yticklabels([1e-4, 0.5, 1])
            ax1.set_yticklabels([f'$10^{{{-ratio}}}$', 0.5, 1])
        ax1.set_aspect('equal')
        if kk == 0:
            ax1.set_xlabel('x coordinate')
        if kk == 1:
            # ax1.set_ylabel(f'Phase' + r' $\rho$')  # f' \n  (linear scale)')
            pass
        if kk == 2:
            ax1.set_title(f'Cross sections')  # , loc='bottom'
            # Add the title below the plot
            # ax1.text(0.5, 0.05, 'My Plot Title', ha='center', fontsize=14)
            ax1.text(-0.1, 1.3, '(c)', transform=ax1.transAxes)
        counter += 1
    fname = src + 'JG_exp4_GRID_DEP_nb_its{}_geom_{}_rho{}{}'.format(geometry_ID, precc, phase_contrast, '.pdf')
    print(('create figure: {}'.format(fname)))
    plt.savefig(fname, bbox_inches='tight')

plt.show()
quit()
######                                                                laminate  2 ratio of nb iterations
nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10]
Nx = (np.asarray(nb_pix_multips))
X, Y = np.meshgrid(Nx, Nx, indexing='ij')

nb_pix_multips = [2, 4, 10]
# material distribution
geometry_ID = 'laminate2'  # laminate2       # 'abs_val'  sine_wave_
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']

for phase_contrast in [1, 4]:
    ratio = phase_contrast
    fig = plt.figure(figsize=(11, 4.5))
    gs = fig.add_gridspec(1, 2, hspace=0.2, wspace=0.1, width_ratios=[3, 2],
                          height_ratios=[1])
    # rigth subplots
    gs2 = gs[0, 1].subgridspec(3, 2, hspace=0.1, wspace=0.01, width_ratios=[1, 1], height_ratios=[1, 1, 1])
    # plot nb its
    gs1 = gs[0, 0].subgridspec(1, 2, wspace=0.3, width_ratios=[0.2, 5])
    ax = fig.add_subplot(gs1[0, 1])
    if phase_contrast == 1:
        relative_nb_iterations_1 = (nb_it_combi_laminate2_1[:, :]) / nb_it_Green_laminate2_1[:, :]
    elif phase_contrast == 4:
        relative_nb_iterations_1 = (nb_it_combi_laminate2_4[:, :]) / nb_it_Green_laminate2_4[:, :]

    relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
    for i in range(relative_nb_iterations_1.shape[0]):
        for j in range(relative_nb_iterations_1.shape[1]):
            if relative_nb_iterations_1[i, j] > 1:
                ax.text(i + Nx[0], j + Nx[0], f'{relative_nb_iterations_1[i, j]:.1f}',
                        ha='center', va='center', color='white')
            else:
                ax.text(i + Nx[0], j + Nx[0], f'{1 / relative_nb_iterations_1[i, j]:.1f}',
                        ha='center', va='center', color='white')
    divnorm = mpl.colors.LogNorm(vmin=0.1, vmax=10)
    # Replace NaN values with zero

    pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

    ax.text(0.1, 0.8, f'Total phase contrast $\kappa=10^{phase_contrast}$', transform=ax.transAxes)
    ax.set_title('Relative number of iteration \n Jacobi-Green / Green ')
    # ax.set_zlim(1 ,100)
    ax.set_ylabel(r'\# data/geometry sampling points (x direction)')

    # ax.yaxis.set_label_position('right')
    # ax.yaxis.tick_right()
    ax.set_xlabel(r'\# of nodal points (x direction)')
    ax.set_xticks(Nx)
    ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
    # ax2 = ax.twinx()
    ax.set_yticks(Nx)
    ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
    ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
    # Adding a color bar with custom ticks and labels
    cbar_ax = fig.add_subplot(gs1[0, 0])

    cbar = plt.colorbar(pcm, location='left', cax=cbar_ax)  # Specify the ticks
    cbar.ax.invert_yaxis()
    # cbar.set_ticks(ticks=[  0, 1,10])
    cbar.set_ticks([10, 5, 2, 1, 1 / 2, 1 / 5, 1 / 10])
    cbar.ax.set_yticklabels(
        ['Jacobi-Green \n needs less', '5 times', '2 times', 'Equal', '2 times', '5 times',
         'Jacobi-Green \n needs more'])
    # ax2.set_yticks(Nx)
    # ax2.set_yticklabels([f'$2^{i}$' for i in Nx])
    # plt.show()
    # arrow 0
    ax.annotate(text='',
                xy=(1.17, 0.16), xycoords='axes fraction',
                xytext=(1.01, 0.06),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    # arrow 1
    ax.annotate(text='',
                xy=(1.17, 0.50),
                xycoords='axes fraction',
                xytext=(1.01, 0.31),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    # arrow 2
    ax.annotate(text='',
                xy=(1.17, 0.83), xycoords='axes fraction',
                xytext=(1.01, 0.94),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    ax.text(-0.1, 1.09, '(a)', transform=ax.transAxes)
    # ax.set_zlabel('# CG iterations')

    #
    counter = 0
    for kk in np.arange(np.size(nb_pix_multips)):
        nb_pix_multip = nb_pix_multips[kk]
        print(f'kk = {kk}')
        print(f'nb_pix_multip = {nb_pix_multip}')
        # system set up
        number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

        my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                          problem_type=problem_type)

        discretization = domain.Discretization(cell=my_cell,
                                               nb_of_pixels_global=number_of_pixels,
                                               discretization_type=discretization_type,
                                               element_type=element_type)

        # if kk == 0:
        phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                          microstructure_name=geometry_ID,
                                                          coordinates=discretization.fft.coords,
                                                          seed=1,
                                                          parameter=number_of_pixels[0],
                                                          contrast=1 / 10 ** ratio
                                                          )
        phase_field += 1 / 10 ** ratio
        phase_field = scale_field(phase_field, min_val=1 / 10 ** ratio, max_val=1.0)
        # phase_fied_small_grid=np.copy(phase_field_smooth)
        phase_field = np.copy(phase_field)

        x = np.arange(0, 1 * number_of_pixels[0])
        y = np.arange(0, 1 * number_of_pixels[1])
        X_, Y_ = np.meshgrid(x, y)

        print(f'kk = {kk}')

        ax0 = fig.add_subplot(gs2[2 - kk, 0])
        ax0.pcolormesh(X_, Y_, np.transpose(phase_field),
                       cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                       rasterized=True)
        # ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
        #           linestyle=linestyles[counter], linewidth=1.)
        # ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
        extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
        extended_y = np.append(np.diag(phase_field), np.diag(phase_field)[-1])
        #
        # ax0.plot([-0.5, number_of_pixels[0] - 0.5], [-0.5, number_of_pixels[1] - 0.5], color=colors[counter],
        #          linestyle=linestyles[counter], linewidth=1., transform=ax0.transAxes)

        ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
                   linestyle=linestyles[counter], linewidth=1.)
        ax0.set_xticks([])
        ax0.set_yticks([])
        ax0.set_aspect('equal')
        if kk == 0:
            ax0.set_xlabel('x coordinate')
        if kk == 2:
            ax0.set_title(r'Geometries')

            ax0.text(-0.3, 1.3, '(b)', transform=ax0.transAxes)
        ax1 = fig.add_subplot(gs2[2 - kk, 1])

        ax1.step(extended_x, extended_y
                 , where='post',
                 linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
                 label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
        # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
        ax1.set_ylim([1 / 10 ** ratio - 0.5 / 10 ** ratio, 1.1])
        ax1.set_xlim([0, 1])
        ax1.set_xticks([])
        ax1.set_xticklabels([])

        ax1.set_yticks([1 / 10 ** ratio, 0.50, 1.0001])
        ax1.set_yticklabels([1 / 10 ** ratio, 0.50, 1.00])
        ax1.yaxis.set_label_position('right')
        ax1.yaxis.tick_right()
        ax1.set_xticks([])
        ax1.set_xticklabels([])

        ax1.set_aspect('equal')
        if kk == 0:
            ax1.set_xlabel('x coordinate')
        if kk == 1:
            ax1.set_ylabel(f'Phase' + r' $\rho$')  # f' \n  (linear scale)')
        if kk == 2:
            ax1.set_title(f'Cross sections')

            ax1.text(-0.3, 1.3, '(c)', transform=ax1.transAxes)
        counter += 1
    fname = src + 'JG_exp4_GRID_DEP_geometry_{}_rho{}{}'.format(geometry_ID, phase_contrast, '.pdf')
    print(('create figure: {}'.format(fname)))
    plt.savefig(fname, bbox_inches='tight')

plt.show()

### plot geometry ################################### abs_val

nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
Nx = (np.asarray(nb_pix_multips))
X, Y = np.meshgrid(Nx, Nx, indexing='ij')

nb_pix_multips = [2, 4, 9]
# material distribution
geometry_ID = 'abs_val'  # laminate2       # 'abs_val'
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']

for phase_contrast in [1, 4]:
    ratio = phase_contrast
    fig = plt.figure(figsize=(11, 4.5))
    gs = fig.add_gridspec(1, 2, hspace=0.2, wspace=0.1, width_ratios=[3, 2],
                          height_ratios=[1])
    # rigth subplots
    gs2 = gs[0, 1].subgridspec(3, 2, hspace=0.1, wspace=0.01, width_ratios=[1, 1], height_ratios=[1, 1, 1])
    # plot nb its
    gs1 = gs[0, 0].subgridspec(1, 2, wspace=0.3, width_ratios=[0.2, 5])
    ax = fig.add_subplot(gs1[0, 1])
    if phase_contrast == 1:
        relative_nb_iterations_1 = (nb_it_combi_abs_1[:, :]) / nb_it_Green_abs_1[:, :]
    elif phase_contrast == 4:
        relative_nb_iterations_1 = (nb_it_combi_abs_4[:, :]) / nb_it_Green_abs_4[:, :]

    relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
    for i in range(relative_nb_iterations_1.shape[0]):
        for j in range(relative_nb_iterations_1.shape[1]):
            if relative_nb_iterations_1[i, j] > 1:
                ax.text(i + 2, j + 2, f'{relative_nb_iterations_1[i, j]:.1f}',
                        ha='center', va='center', color='white')
            else:
                ax.text(i + 2, j + 2, f'{1 / relative_nb_iterations_1[i, j]:.1f}',
                        ha='center', va='center', color='white')
    divnorm = mpl.colors.LogNorm(vmin=0.1, vmax=10)
    # Replace NaN values with zero

    pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

    ax.text(0.1, 0.8, f'Total phase contrast $\kappa=10^{phase_contrast}$', transform=ax.transAxes)
    ax.set_title('Relative number of iteration \n Jacobi-Green / Green ')
    # ax.set_zlim(1 ,100)
    ax.set_ylabel(r'\# data/geometry sampling points (x direction)')

    # ax.yaxis.set_label_position('right')
    # ax.yaxis.tick_right()
    ax.set_xlabel(r'\# of nodal points (x direction)')
    ax.set_xticks(Nx)
    ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
    # ax2 = ax.twinx()
    ax.set_yticks(Nx)
    ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
    ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)
    # Adding a color bar with custom ticks and labels
    cbar_ax = fig.add_subplot(gs1[0, 0])

    cbar = plt.colorbar(pcm, location='left', cax=cbar_ax)  # Specify the ticks
    cbar.ax.invert_yaxis()
    # cbar.set_ticks(ticks=[  0, 1,10])
    cbar.set_ticks([10, 5, 2, 1, 1 / 2, 1 / 5, 1 / 10])
    cbar.ax.set_yticklabels(
        ['Jacobi-Green \n needs less', '5 times', '2 times', 'Equal', '2 times', '5 times',
         'Jacobi-Green \n needs more'])
    # ax2.set_yticks(Nx)
    # ax2.set_yticklabels([f'$2^{i}$' for i in Nx])
    # plt.show()
    # arrow 0
    ax.annotate(text='',
                xy=(1.17, 0.16), xycoords='axes fraction',
                xytext=(1.01, 0.06),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    # arrow 1
    ax.annotate(text='',
                xy=(1.17, 0.50),
                xycoords='axes fraction',
                xytext=(1.01, 0.31),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    # arrow 2
    ax.annotate(text='',
                xy=(1.17, 0.83), xycoords='axes fraction',
                xytext=(1.01, 0.94),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    ax.text(-0.1, 1.09, '(a)', transform=ax.transAxes)
    # ax.set_zlabel('# CG iterations')

    #
    counter = 0
    for kk in np.arange(np.size(nb_pix_multips)):
        nb_pix_multip = nb_pix_multips[kk]
        print(f'kk = {kk}')
        print(f'nb_pix_multip = {nb_pix_multip}')
        # system set up
        number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

        my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                          problem_type=problem_type)

        discretization = domain.Discretization(cell=my_cell,
                                               nb_of_pixels_global=number_of_pixels,
                                               discretization_type=discretization_type,
                                               element_type=element_type)

        # if kk == 0:
        phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                          microstructure_name=geometry_ID,
                                                          coordinates=discretization.fft.coords,
                                                          seed=1,
                                                          parameter=number_of_pixels[0],
                                                          contrast=1 / 10 ** ratio
                                                          )
        phase_field += 1 / 10 ** ratio
        phase_field = scale_field(phase_field, min_val=1 / 10 ** ratio, max_val=1.0)
        # phase_fied_small_grid=np.copy(phase_field_smooth)
        phase_field = np.copy(phase_field)

        x = np.arange(0, 1 * number_of_pixels[0])
        y = np.arange(0, 1 * number_of_pixels[1])
        X_, Y_ = np.meshgrid(x, y)

        print(f'kk = {kk}')

        ax0 = fig.add_subplot(gs2[2 - kk, 0])
        ax0.pcolormesh(X_, Y_, np.transpose(phase_field),
                       cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                       rasterized=True)
        # ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
        #           linestyle=linestyles[counter], linewidth=1.)
        # ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
        extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
        extended_y = np.append(np.diag(phase_field), np.diag(phase_field)[-1])

        ax0.plot([-0.5, number_of_pixels[0] - 0.5], [-0.5, number_of_pixels[1] - 0.5], color=colors[counter],
                 linestyle=linestyles[counter], linewidth=1., transform=ax0.transAxes)
        ax0.set_xticks([])
        ax0.set_yticks([])
        ax0.set_aspect('equal')
        if kk == 0:
            ax0.set_xlabel('x coordinate')
        if kk == 2:
            ax0.set_title(r'Geometries')

            ax0.text(-0.3, 1.3, '(b)', transform=ax0.transAxes)
        ax1 = fig.add_subplot(gs2[2 - kk, 1])
        ax1.step(extended_x, extended_y
                 , where='post',
                 linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
                 label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')

        # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
        ax1.set_ylim([1 / 10 ** ratio - 0.5 / 10 ** ratio, 1.1])
        ax1.set_xlim([0, 1])
        ax1.set_xticks([])
        ax1.set_xticklabels([])

        ax1.set_yticks([1 / 10 ** ratio, 0.50, 1.0001])
        ax1.set_yticklabels([1 / 10 ** ratio, 0.50, 1.00])
        ax1.yaxis.set_label_position('right')
        ax1.yaxis.tick_right()
        ax1.set_xticks([])
        ax1.set_xticklabels([])

        ax1.set_aspect('equal')
        if kk == 0:
            ax1.set_xlabel('x coordinate')
        if kk == 1:
            ax1.set_ylabel(f'Phase' + r' $\rho$')  # f' \n  (linear scale)')
        if kk == 2:
            ax1.set_title(f'Cross sections')

            ax1.text(-0.3, 1.3, '(c)', transform=ax1.transAxes)
        counter += 1
    fname = src + 'JG_exp4_GRID_DEP_geometry_abs_rho{}{}'.format(phase_contrast, '.pdf')
    print(('create figure: {}'.format(fname)))
    plt.savefig(fname, bbox_inches='tight')

plt.show()

### plot geometry ################################### sine_wave_
nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10]
Nx = (np.asarray(nb_pix_multips))
X, Y = np.meshgrid(Nx, Nx, indexing='ij')

nb_pix_multips = [2, 4, 9]
# material distribution
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']

geometry_ID = 'sine_wave_'
for phase_contrast in [1, 4]:
    ratio = phase_contrast
    fig = plt.figure(figsize=(11, 4.5))
    gs = fig.add_gridspec(1, 2, hspace=0.2, wspace=0.1, width_ratios=[3, 2],
                          height_ratios=[1])
    # rigth subplots
    gs2 = gs[0, 1].subgridspec(3, 2, hspace=0.1, wspace=0.01, width_ratios=[1, 1], height_ratios=[1, 1, 1])
    # plot nb its
    gs1 = gs[0, 0].subgridspec(1, 2, wspace=0.3, width_ratios=[0.2, 5])
    ax = fig.add_subplot(gs1[0, 1])
    if phase_contrast == 1:
        relative_nb_iterations_1 = (nb_it_combi_1[:, :]) / nb_it_Green_1[:, :]
    elif phase_contrast == 4:
        relative_nb_iterations_1 = (nb_it_combi_4[:, :]) / nb_it_Green_4[:, :]

    relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
    for i in range(relative_nb_iterations_1.shape[0]):
        for j in range(relative_nb_iterations_1.shape[1]):
            if relative_nb_iterations_1[i, j] > 1:
                ax.text(i + 2, j + 2, f'{relative_nb_iterations_1[i, j]:.1f}',
                        ha='center', va='center', color='white')
            else:
                ax.text(i + 2, j + 2, f'{1 / relative_nb_iterations_1[i, j]:.1f}',
                        ha='center', va='center', color='white')
    #    divnorm = mpl.colors.TwoSlopeNorm(vmin=0., vcenter=1., vmax=relative_nb_iterations_1.max())
    divnorm = mpl.colors.LogNorm(vmin=0.1, vmax=10)

    # Replace NaN values with zero

    pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

    ax.text(0.1, 0.8, f'Total phase contrast $\kappa=10^{phase_contrast}$', transform=ax.transAxes)
    ax.set_title('Relative number of iteration \n Jacobi-Green / Green ')
    # ax.set_zlim(1 ,100)
    ax.set_ylabel(r'\# data/geometry sampling points (x direction)')

    # ax.yaxis.set_label_position('right')
    # ax.yaxis.tick_right()
    ax.set_xlabel(r'\# of nodal points (x direction)')
    ax.set_xticks(Nx)
    ax.set_xticklabels([f'$2^{{{i}}}$' for i in Nx])
    # ax2 = ax.twinx()
    ax.set_yticks(Nx)
    ax.set_yticklabels([f'$2^{{{i}}}$' for i in Nx])
    ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)

    # ax2.set_yticks(Nx)
    # ax2.set_yticklabels([f'$2^{i}$' for i in Nx])

    # arrow 0
    ax.annotate(text='',
                xy=(1.17, 0.16), xycoords='axes fraction',
                xytext=(1.01, 0.06),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    # arrow 1
    ax.annotate(text='',
                xy=(1.17, 0.50),
                xycoords='axes fraction',
                xytext=(1.01, 0.31),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    # arrow 2
    ax.annotate(text='',
                xy=(1.17, 0.83), xycoords='axes fraction',
                xytext=(1.01, 0.94),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    ax.text(-0.1, 1.09, '(a)', transform=ax.transAxes)
    # ax.set_zlabel('# CG iterations')
    # Adding a color bar with custom ticks and labels
    cbar_ax = fig.add_subplot(gs1[0, 0])

    cbar = plt.colorbar(pcm, location='left', cax=cbar_ax)  # Specify the ticks
    cbar.ax.invert_yaxis()
    # cbar.set_ticks(ticks=[  0, 1,10])
    cbar.set_ticks([10, 5, 2, 1, 1 / 2, 1 / 5, 1 / 10])
    cbar.ax.set_yticklabels(
        ['Jacobi-Green \n needs less', '5 times', '2 times', 'Equal', '2 times', '5 times',
         'Jacobi-Green \n needs more'])
    #
    counter = 0
    for kk in np.arange(np.size(nb_pix_multips)):
        nb_pix_multip = nb_pix_multips[kk]
        print(f'kk = {kk}')
        print(f'nb_pix_multip = {nb_pix_multip}')
        # system set up
        number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

        my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                          problem_type=problem_type)

        discretization = domain.Discretization(cell=my_cell,
                                               nb_of_pixels_global=number_of_pixels,
                                               discretization_type=discretization_type,
                                               element_type=element_type)

        # if kk == 0:
        phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                          microstructure_name=geometry_ID,
                                                          coordinates=discretization.fft.coords,
                                                          seed=1)
        phase_field += 1 / 10 ** ratio
        phase_field = scale_field(phase_field, min_val=1 / 10 ** ratio, max_val=1.0)
        # phase_fied_small_grid=np.copy(phase_field_smooth)
        phase_field = np.copy(phase_field)

        x = np.arange(0, 1 * number_of_pixels[0])
        y = np.arange(0, 1 * number_of_pixels[1])
        X_, Y_ = np.meshgrid(x, y)

        print(f'kk = {kk}')

        ax0 = fig.add_subplot(gs2[2 - kk, 0])
        ax0.pcolormesh(X_, Y_, np.transpose(phase_field),
                       cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                       rasterized=True)
        # ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
        #           linestyle=linestyles[counter], linewidth=1.)
        # ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
        extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
        extended_y = np.append(phase_field[:, phase_field.shape[0] // 2],
                               phase_field[:, phase_field.shape[0] // 2][-1])
        ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
                   linestyle=linestyles[counter], linewidth=1.)
        ax0.set_xticks([])
        ax0.set_yticks([])
        ax0.set_aspect('equal')
        if kk == 0:
            ax0.set_xlabel('x coordinate')
        if kk == 2:
            ax0.set_title(r'Geometries')

            ax0.text(-0.3, 1.3, '(b)', transform=ax0.transAxes)
        ax1 = fig.add_subplot(gs2[2 - kk, 1])
        ax1.step(extended_x, extended_y
                 , where='post',
                 linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
                 label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')

        # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
        ax1.set_ylim([1 / 10 ** ratio - 0.5 / 10 ** ratio, 1.1])
        ax1.set_xlim([0, 1])
        ax1.set_xticks([])
        ax1.set_xticklabels([])

        ax1.set_yticks([1 / 10 ** ratio, 0.50, 1.0001])
        ax1.set_yticklabels([1 / 10 ** ratio, 0.50, 1.00])
        ax1.yaxis.set_label_position('right')
        ax1.yaxis.tick_right()
        ax1.set_xticks([])
        ax1.set_xticklabels([])

        ax1.set_aspect('equal')
        if kk == 0:
            ax1.set_xlabel('x coordinate')
        if kk == 1:
            ax1.set_ylabel(f'Phase' + r' $\rho$')  # f' \n  (linear scale)')
        if kk == 2:
            ax1.set_title(f'Cross sections')

            ax1.text(-0.3, 1.3, '(c)', transform=ax1.transAxes)
        counter += 1
    fname = src + 'JG_exp4_GRID_DEP_geometry_rho{}{}'.format(phase_contrast, '.pdf')
    print(('create figure: {}'.format(fname)))
    plt.savefig(fname, bbox_inches='tight')

plt.show()
### plot geometry ################################### sine_wave_inv
nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9]
Nx = (np.asarray(nb_pix_multips))
X, Y = np.meshgrid(Nx, Nx, indexing='ij')

nb_pix_multips = [2, 4, 9]
# material distribution
geometry_ID = 'sine_wave_inv'
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']

for phase_contrast in [4]:
    ratio = phase_contrast
    fig = plt.figure(figsize=(11, 4.5))
    gs = fig.add_gridspec(1, 2, hspace=0.2, wspace=0.1, width_ratios=[3, 2],
                          height_ratios=[1])
    # rigth subplots
    gs2 = gs[0, 1].subgridspec(3, 2, hspace=0.1, wspace=0.01, width_ratios=[1, 1], height_ratios=[1, 1, 1])
    # plot nb its
    gs1 = gs[0, 0].subgridspec(1, 2, wspace=0.3, width_ratios=[0.2, 5])
    ax = fig.add_subplot(gs1[0, 1])
    if phase_contrast == 4:
        relative_nb_iterations_1 = (nb_it_combi_4_0_inv[:, :]) / nb_it_Green_4_0_inv[:, :]

    relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
    for i in range(relative_nb_iterations_1.shape[0]):
        for j in range(relative_nb_iterations_1.shape[1]):
            if relative_nb_iterations_1[i, j] > 1:
                ax.text(i + 2, j + 2, f'{relative_nb_iterations_1[i, j]:.1f}',
                        ha='center', va='center', color='white')
            else:
                ax.text(i + 2, j + 2, f'{1 / relative_nb_iterations_1[i, j]:.1f}',
                        ha='center', va='center', color='white')
    #    divnorm = mpl.colors.TwoSlopeNorm(vmin=0., vcenter=1., vmax=relative_nb_iterations_1.max())
    divnorm = mpl.colors.LogNorm(vmin=0.1, vmax=10)

    # Replace NaN values with zero

    pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

    ax.text(0.1, 0.8, r'Total phase contrast $\kappa=\infty$', transform=ax.transAxes)
    ax.set_title('Relative number of iteration \n Jacobi-Green / Green ')
    # ax.set_zlim(1 ,100)
    ax.set_ylabel(r'\# data/geometry sampling points (x direction)')

    # ax.yaxis.set_label_position('right')
    # ax.yaxis.tick_right()
    ax.set_xlabel(r'\# of nodal points (x direction)')
    ax.set_xticks(Nx)
    ax.set_xticklabels([f'$2^{i}$' for i in Nx])
    # ax2 = ax.twinx()
    ax.set_yticks(Nx)
    ax.set_yticklabels([f'$2^{i}$' for i in Nx])
    ax.tick_params(right=True, top=False, labelright=False, labeltop=False, labelrotation=0)

    # ax2.set_yticks(Nx)
    # ax2.set_yticklabels([f'$2^{i}$' for i in Nx])

    # arrow 0
    ax.annotate(text='',
                xy=(1.17, 0.16), xycoords='axes fraction',
                xytext=(1.01, 0.06),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    # arrow 1
    ax.annotate(text='',
                xy=(1.17, 0.50),
                xycoords='axes fraction',
                xytext=(1.01, 0.31),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    # arrow 2
    ax.annotate(text='',
                xy=(1.17, 0.83), xycoords='axes fraction',
                xytext=(1.01, 0.94),
                arrowprops=dict(arrowstyle='->',
                                color='black',
                                lw=1,
                                ls='-')
                )
    ax.text(-0.1, 1.09, '(a)', transform=ax.transAxes)
    # ax.set_zlabel('# CG iterations')
    # Adding a color bar with custom ticks and labels
    cbar_ax = fig.add_subplot(gs1[0, 0])

    cbar = plt.colorbar(pcm, location='left', cax=cbar_ax)  # Specify the ticks
    cbar.ax.invert_yaxis()
    # cbar.set_ticks(ticks=[  0, 1,10])
    cbar.set_ticks([10, 5, 2, 1, 1 / 2, 1 / 5, 1 / 10])
    cbar.ax.set_yticklabels(
        ['Jacobi-Green \n needs less', '5 times', '2 times', 'Equal', '2 times', '5 times',
         'Jacobi-Green \n needs more'])
    #
    counter = 0
    for kk in np.arange(np.size(nb_pix_multips)):
        nb_pix_multip = nb_pix_multips[kk]
        print(f'kk = {kk}')
        print(f'nb_pix_multip = {nb_pix_multip}')
        # system set up
        number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

        my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                          problem_type=problem_type)

        discretization = domain.Discretization(cell=my_cell,
                                               nb_of_pixels_global=number_of_pixels,
                                               discretization_type=discretization_type,
                                               element_type=element_type)

        # if kk == 0:
        phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                          microstructure_name=geometry_ID,
                                                          coordinates=discretization.fft.coords,
                                                          seed=1)
        # phase_field += 1 / 10 ** ratio
        phase_field = scale_field(phase_field, min_val=1 / 10 ** ratio, max_val=1.0)
        # phase_fied_small_grid=np.copy(phase_field_smooth)
        phase_field = np.copy(phase_field)

        x = np.arange(0, 1 * number_of_pixels[0])
        y = np.arange(0, 1 * number_of_pixels[1])
        X_, Y_ = np.meshgrid(x, y)

        print(f'kk = {kk}')

        ax0 = fig.add_subplot(gs2[2 - kk, 0])
        ax0.pcolormesh(X_, Y_, np.transpose(phase_field),
                       cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                       rasterized=True)
        # ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
        #           linestyle=linestyles[counter], linewidth=1.)
        # ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
        extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
        extended_y = np.append(phase_field[:, phase_field.shape[0] // 2],
                               phase_field[:, phase_field.shape[0] // 2][-1])
        ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
                   linestyle=linestyles[counter], linewidth=1.)
        ax0.set_xticks([])
        ax0.set_yticks([])
        ax0.set_aspect('equal')
        if kk == 0:
            ax0.set_xlabel('x coordinate')
        if kk == 2:
            ax0.set_title(r'Geometries')

            ax0.text(-0.3, 1.3, '(b)', transform=ax0.transAxes)
        ax1 = fig.add_subplot(gs2[2 - kk, 1])
        ax1.step(extended_x, extended_y
                 , where='post',
                 linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
                 label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')

        # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
        ax1.set_ylim([0, 1.1])
        ax1.set_xlim([0, 1])
        ax1.set_xticks([])
        ax1.set_xticklabels([])

        ax1.set_yticks([0, 0.50, 1.0001])
        ax1.set_yticklabels([0, 0.50, 1.00])
        ax1.yaxis.set_label_position('right')
        ax1.yaxis.tick_right()
        ax1.set_xticks([])
        ax1.set_xticklabels([])

        ax1.set_aspect('equal')
        if kk == 0:
            ax1.set_xlabel('x coordinate')
        if kk == 1:
            ax1.set_ylabel(f'Phase' + r' $\rho$')  # f' \n  (linear scale)')
        if kk == 2:
            ax1.set_title(f'Cross sections')

            ax1.text(-0.3, 1.3, '(c)', transform=ax1.transAxes)
        counter += 1
    fname = src + 'JG_exp4_GRID_DEP_geometry_sine_inv_inf_rho{}{}'.format(phase_contrast, '.pdf')
    print(('create figure: {}'.format(fname)))
    plt.savefig(fname, bbox_inches='tight')

plt.show()

nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9]
Nx = (np.asarray(nb_pix_multips))
X, Y = np.meshgrid(Nx, Nx, indexing='ij')

fig = plt.figure(figsize=(5.5, 4.5))
# ax = fig.add_subplot(111, projection='3d')
ax = fig.add_subplot(111)
# Setting the view angle
# ax.view_init(elev=-0, azim=0)  # Adjust these values as needed
# Plotting the surface
# ax.plot_surface(X, Y, nb_it_Green[:, :], label='PCG: Green', color='green')
# ax.plot_wireframe(X, Y, nb_it_Jacobi[:, :], label='PCG: Jacobi', color='black')
# ax.plot_surface(X, Y, nb_it_combi[:, :], label='PCG: Green + Jacobi', color='red')
relative_nb_iterations = (nb_it_combi_4[:, :]) / nb_it_Green_4[:, :]
relative_nb_iterations = np.nan_to_num(relative_nb_iterations, nan=1.0)

divnorm = mpl.colors.TwoSlopeNorm(vmin=0., vcenter=1., vmax=relative_nb_iterations.max())
# Replace NaN values with zero

pcm = ax.pcolormesh(X, Y, relative_nb_iterations, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)
# Add text annotations
for i in range(relative_nb_iterations.shape[0]):
    for j in range(relative_nb_iterations.shape[1]):
        if relative_nb_iterations[i, j] > 1:
            ax.text(i + 2, j + 2, f'{relative_nb_iterations[i, j]:.1f}',
                    ha='center', va='center', color='white')
        else:
            ax.text(i + 2, j + 2, f'{1 / relative_nb_iterations[i, j]:.1f}',
                    ha='center', va='center', color='white')

ax.text(0.1, 0.8, r'Total phase contrast $\kappa=10^4$', transform=ax.transAxes)
ax.set_title('Relative number of iteration \n' + r' nb_{JG}/nb_{G}'
                                                 '\n cosine function')
# ax.set_zlim(1 ,100)
ax.set_ylabel(r'\# data/geometry sampling points (x direction)')
ax.set_xlabel(r'\# of nodal points (x direction)')
ax.set_xticks(Nx)
ax.set_xticklabels([f'$2^{i}$' for i in Nx])
ax.set_yticks(Nx)
ax.set_yticklabels([f'$2^{i}$' for i in Nx])
# ax.set_zlabel('# CG iterations')
# Adding a color bar with custom ticks and labels
cbar = plt.colorbar(pcm)  # Specify the ticks
# cbar.set_ticks(ticks=[  0, 1,10])
cbar.set_ticks([0, 0.2, 0.5, 1, 2, 5, relative_nb_iterations.max()])
cbar.ax.set_yticklabels(
    ['Jacobi-Green \n is better', '5 times', '2 times', 'Equal', '2 times', '5 times', 'Green \n is better'])
# plt.legend(['PCG: Green'])
fname = src + 'JG_exp4_GRID_DEP_matrix_rho4{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')
plt.show()

fig = plt.figure(figsize=(5.5, 4.5))
# ax = fig.add_subplot(111, projection='3d')
ax = fig.add_subplot(111)
# Setting the view angle
# ax.view_init(elev=-0, azim=0)  # Adjust these values as needed
# Plotting the surface
# ax.plot_surface(X, Y, nb_it_Green[:, :], label='PCG: Green', color='green')
# ax.plot_wireframe(X, Y, nb_it_Jacobi[:, :], label='PCG: Jacobi', color='black')
# ax.plot_surface(X, Y, nb_it_combi[:, :], label='PCG: Green + Jacobi', color='red')
relative_nb_iterations_1 = (nb_it_combi_1[:, :]) / nb_it_Green_1[:, :]
relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
for i in range(relative_nb_iterations_1.shape[0]):
    for j in range(relative_nb_iterations_1.shape[1]):
        ax.text(i + 2, j + 2, f'{relative_nb_iterations_1[i, j]:.2f}',
                ha='center', va='center', color='white')
divnorm = mpl.colors.TwoSlopeNorm(vmin=0., vcenter=1., vmax=relative_nb_iterations.max())
# Replace NaN values with zero

pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

ax.text(0.1, 0.8, r'Total phase contrast $\kappa=10^1$', transform=ax.transAxes)
ax.set_title('Relative number of iteration \n cosine function')
# ax.set_zlim(1 ,100)
ax.set_ylabel(r'\# data/geometry sampling points (x direction)')
ax.set_xlabel(r'\# of nodal points (x direction)')
ax.set_xticks(Nx)
ax.set_xticklabels([f'$2^{i}$' for i in Nx])
ax.set_yticks(Nx)
ax.set_yticklabels([f'$2^{i}$' for i in Nx])
# ax.set_zlabel('# CG iterations')
# Adding a color bar with custom ticks and labels
cbar = plt.colorbar(pcm)  # Specify the ticks
# cbar.set_ticks(ticks=[  0, 1,10])
cbar.set_ticks([0, 0.2, 0.5, 1, 2, 5, relative_nb_iterations.max()])
cbar.ax.set_yticklabels(
    ['Jacobi-Green \n is better', '5 times', '2 times', 'Equal', '2 times', '5 times', 'Green \n is better'])
# plt.legend(['PCG: Green'])
fname = src + 'JG_exp4_GRID_DEP_matrix_rho1{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')
plt.show()

fig = plt.figure(figsize=(5.5, 4.5))
# ax = fig.add_subplot(111, projection='3d')
ax = fig.add_subplot(111)
# Setting the view angle
# ax.view_init(elev=-0, azim=0)  # Adjust these values as needed
# Plotting the surface
# ax.plot_surface(X, Y, nb_it_Green[:, :], label='PCG: Green', color='green')
# ax.plot_wireframe(X, Y, nb_it_Jacobi[:, :], label='PCG: Jacobi', color='black')
# ax.plot_surface(X, Y, nb_it_combi[:, :], label='PCG: Green + Jacobi', color='red')
relative_nb_iterations_1 = (nb_it_combi_1_0[:, :]) / nb_it_Green_1_0[:, :]
relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
for i in range(relative_nb_iterations_1.shape[0]):
    for j in range(relative_nb_iterations_1.shape[1]):
        ax.text(i + 2, j + 2, f'{relative_nb_iterations_1[i, j]:.2f}',
                ha='center', va='center', color='white')
divnorm = mpl.colors.TwoSlopeNorm(vmin=0., vcenter=1., vmax=relative_nb_iterations.max())
# Replace NaN values with zero

pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

ax.text(0.1, 0.8, r'Total phase contrast $\kappa=10^1$', transform=ax.transAxes)
ax.set_title('Relative number of iteration \n cosine function _ zeros')
# ax.set_zlim(1 ,100)
ax.set_ylabel(r'\# data/geometry sampling points (x direction)')
ax.set_xlabel(r'\# of nodal points (x direction)')
ax.set_xticks(Nx)
ax.set_xticklabels([f'$2^{i}$' for i in Nx])
ax.set_yticks(Nx)
ax.set_yticklabels([f'$2^{i}$' for i in Nx])
# ax.set_zlabel('# CG iterations')
# Adding a color bar with custom ticks and labels
cbar = plt.colorbar(pcm)  # Specify the ticks
# cbar.set_ticks(ticks=[  0, 1,10])
cbar.set_ticks([0, 0.2, 0.5, 1, 2, 5, relative_nb_iterations.max()])
cbar.ax.set_yticklabels(
    ['Jacobi-Green \n is better', '5 times', '2 times', 'Equal', '2 times', '5 times', 'Green \n is better'])
# plt.legend(['PCG: Green'])
fname = src + 'JG_exp4_GRID_DEP_matrix_rho1_inf{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')
plt.show()

fig = plt.figure(figsize=(5.5, 4.5))
# ax = fig.add_subplot(111, projection='3d')
ax = fig.add_subplot()
# Setting the view angle
# ax.view_init(elev=-0, azim=0)  # Adjust these values as needed
# Plotting the surface
# ax.plot_surface(X, Y, nb_it_Green[:, :], label='PCG: Green', color='green')
# ax.plot_wireframe(X, Y, nb_it_Jacobi[:, :], label='PCG: Jacobi', color='black')
# ax.plot_surface(X, Y, nb_it_combi[:, :], label='PCG: Green + Jacobi', color='red')
relative_nb_iterations_1 = (nb_it_combi_4_0[:, :]) / nb_it_Green_4_0[:, :]
relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
for i in range(relative_nb_iterations_1.shape[0]):
    for j in range(relative_nb_iterations_1.shape[1]):
        ax.text(i + 2, j + 2, f'{relative_nb_iterations_1[i, j]:.2f}',
                ha='center', va='center', color='white')
divnorm = mpl.colors.TwoSlopeNorm(vmin=0., vcenter=1., vmax=relative_nb_iterations.max())
# Replace NaN values with zero

pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

ax.text(0.1, 0.8, r'Total phase contrast $\kappa=10^4$', transform=ax.transAxes)
ax.set_title('Relative number of iteration \n cosine function _ zeros')
# ax.set_zlim(1 ,100)
ax.set_ylabel(r'\# data/geometry sampling points (x direction)')
ax.set_xlabel(r'\# of nodal points (x direction)')
ax.set_xticks(Nx)
ax.set_xticklabels([f'$2^{i}$' for i in Nx])
ax.set_yticks(Nx)
ax.set_yticklabels([f'$2^{i}$' for i in Nx])
# ax.set_zlabel('# CG iterations')
# Adding a color bar with custom ticks and labels
cbar = plt.colorbar(pcm)  # Specify the ticks
# cbar.set_ticks(ticks=[  0, 1,10])
cbar.set_ticks([0, 0.2, 0.5, 1, 2, 5, relative_nb_iterations.max()])
cbar.ax.set_yticklabels(
    ['Jacobi-Green \n is better', '5 times', '2 times', 'Equal', '2 times', '5 times', 'Green \n is better'])
# plt.legend(['PCG: Green'])
fname = src + 'JG_exp4_GRID_DEP_matrix_rho4_inf{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')
plt.show()

nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9]
Nx = (np.asarray(nb_pix_multips))
X, Y = np.meshgrid(Nx, Nx, indexing='ij')

fig = plt.figure(figsize=(5.5, 4.5))
# ax = fig.add_subplot(111, projection='3d')
ax = fig.add_subplot()
relative_nb_iterations_1 = (nb_it_combi_4_0_inv[:, :]) / nb_it_Green_4_0_inv[:, :]
relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
for i in range(relative_nb_iterations_1.shape[0]):
    for j in range(relative_nb_iterations_1.shape[1]):
        ax.text(i + 2, j + 2, f'{relative_nb_iterations_1[i, j]:.2f}',
                ha='center', va='center', color='white')
divnorm = mpl.colors.TwoSlopeNorm(vmin=0., vcenter=1., vmax=relative_nb_iterations.max())
# Replace NaN values with zero

pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

ax.text(0.1, 0.8, r'Total phase contrast $\kappa=10^4$', transform=ax.transAxes)
ax.set_title('Relative number of iteration \n cosine function _ zeros inverse')
# ax.set_zlim(1 ,100)
ax.set_ylabel(r'\# data/geometry sampling points (x direction)')
ax.set_xlabel(r'\# of nodal points (x direction)')
ax.set_xticks(Nx)
ax.set_xticklabels([f'$2^{i}$' for i in Nx])
ax.set_yticks(Nx)
ax.set_yticklabels([f'$2^{i}$' for i in Nx])
# ax.set_zlabel('# CG iterations')
# Adding a color bar with custom ticks and labels
cbar = plt.colorbar(pcm)  # Specify the ticks
# cbar.set_ticks(ticks=[  0, 1,10])
cbar.set_ticks([0, 0.2, 0.5, 1, 2, 5, relative_nb_iterations.max()])
cbar.ax.set_yticklabels(
    ['Jacobi-Green \n is better', '5 times', '2 times', 'Equal', '2 times', '5 times', 'Green \n is better'])
# plt.legend(['PCG: Green'])
fname = src + 'JG_exp4_GRID_DEP_matrix_rho4_inf_inv{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')
plt.show()

nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
Nx = (np.asarray(nb_pix_multips))
X, Y = np.meshgrid(Nx, Nx, indexing='ij')
fig = plt.figure(figsize=(5.5, 4.5))
# ax = fig.add_subplot(111, projection='3d')
ax = fig.add_subplot()
relative_nb_iterations_1 = (nb_it_combi_abs_4[:, :]) / nb_it_Green_abs_4[:, :]
relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
for i in range(relative_nb_iterations_1.shape[0]):
    for j in range(relative_nb_iterations_1.shape[1]):
        ax.text(i + 2, j + 2, f'{relative_nb_iterations_1[i, j]:.2f}',
                ha='center', va='center', color='white')
divnorm = mpl.colors.TwoSlopeNorm(vmin=0., vcenter=1., vmax=relative_nb_iterations_1.max())
# Replace NaN values with zero

pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

ax.text(0.1, 0.8, r'Total phase contrast $\kappa=10^4$', transform=ax.transAxes)
ax.set_title('Relative number of iteration \n abs function ')
# ax.set_zlim(1 ,100)
ax.set_ylabel(r'\# data/geometry sampling points (x direction)')
ax.set_xlabel(r'\# of nodal points (x direction)')
ax.set_xticks(Nx)
ax.set_xticklabels([f'$2^{i:}$' for i in Nx])
ax.set_yticks(Nx)
ax.set_yticklabels([f'$2^{i}$' for i in Nx])
# ax.set_zlabel('# CG iterations')
# Adding a color bar with custom ticks and labels
cbar = plt.colorbar(pcm)  # Specify the ticks
# cbar.set_ticks(ticks=[  0, 1,10])
cbar.set_ticks([0, 0.2, 0.5, 1, 2, 5, relative_nb_iterations.max()])
cbar.ax.set_yticklabels(
    ['Jacobi-Green \n is better', '5 times', '2 times', 'Equal', '2 times', '5 times', 'Green \n is better'])
# plt.legend(['PCG: Green'])
fname = src + 'JG_exp4_GRID_DEP_matrix_rho4_abs{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')
plt.show()

fig = plt.figure(figsize=(5.5, 4.5))
# ax = fig.add_subplot(111, projection='3d')
ax = fig.add_subplot()
relative_nb_iterations_1 = (nb_it_combi_abs_1[:, :]) / nb_it_Green_abs_1[:, :]
relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
for i in range(relative_nb_iterations_1.shape[0]):
    for j in range(relative_nb_iterations_1.shape[1]):
        ax.text(i + 2, j + 2, f'{relative_nb_iterations_1[i, j]:.2f}',
                ha='center', va='center', color='white')
divnorm = mpl.colors.TwoSlopeNorm(vmin=0., vcenter=1., vmax=relative_nb_iterations.max())
# Replace NaN values with zero

pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

ax.text(0.1, 0.8, r'Total phase contrast $\kappa=10^1$', transform=ax.transAxes)
ax.set_title('Relative number of iteration \n abs function ')
# ax.set_zlim(1 ,100)
ax.set_ylabel(r'\# data/geometry sampling points (x direction)')
ax.set_xlabel(r'\# of nodal points (x direction)')
ax.set_xticks(Nx)
ax.set_xticklabels([f'$2^{i}$' for i in Nx])
ax.set_yticks(Nx)
ax.set_yticklabels([f'$2^{i}$' for i in Nx])
# ax.set_zlabel('# CG iterations')
# Adding a color bar with custom ticks and labels
cbar = plt.colorbar(pcm)  # Specify the ticks
# cbar.set_ticks(ticks=[  0, 1,10])
cbar.set_ticks([0, 0.2, 0.5, 1, 2, 5, relative_nb_iterations.max()])
cbar.ax.set_yticklabels(
    ['Jacobi-Green \n is better', '5 times', '2 times', 'Equal', '2 times', '5 times', 'Green \n is better'])
# plt.legend(['PCG: Green'])
fname = src + 'JG_exp4_GRID_DEP_matrix_rho1_abs{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')
plt.show()
## number of iteration in 3D
# [[ 5.  0.  0.  0.  0.]
#  [ 7.  9.  0.  0.  0.]
#  [ 8. 11. 13.  0.  0.]
#  [ 9. 12. 17. 17.  0.]
#  [ 9. 12. 16. 15. 14.]]
# [[ 6.  0.  0.  0.  0.]
#  [ 8.  8.  0.  0.  0.]
#  [14. 14. 13.  0.  0.]
#  [25. 22. 22. 20.  0.]
#  [44. 34. 33. 33. 36.]]
# [[ 5.  0.  0.  0.  0.]
#  [ 5.  5.  0.  0.  0.]
#  [ 7.  5.  5.  0.  0.]
#  [10.  6.  5.  4.  0.]
#  [15.  9.  6.  4.  3.]]


quit()

### plot geometry
nb_pix_multips = [2, 4, 9]

# material distribution
geometry_ID = 'sine_wave_'
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']
ratio = np.arange(1, 2)

fig = plt.figure(figsize=(11, 4.5))
gs = fig.add_gridspec(1, 2, hspace=0.2, wspace=0.2, width_ratios=[3, 2],
                      height_ratios=[1])
# rigth subplots
gs2 = gs[0, 1].subgridspec(3, 2, hspace=0.1, wspace=0.1, width_ratios=[1, 1], height_ratios=[1, 1, 1])
# plot nb its
gs1 = gs[0, 0].subgridspec(1, 2, wspace=0.1, width_ratios=[0.2, 5])
ax = fig.add_subplot(gs1[0, 1])

relative_nb_iterations_1 = (nb_it_combi_1[:, :]) / nb_it_Green_1[:, :]
relative_nb_iterations_1 = np.nan_to_num(relative_nb_iterations_1, nan=1.0)
for i in range(relative_nb_iterations_1.shape[0]):
    for j in range(relative_nb_iterations_1.shape[1]):
        ax.text(i + 2, j + 2, f'{relative_nb_iterations_1[i, j]:.2f}',
                ha='center', va='center', color='white')
divnorm = mpl.colors.TwoSlopeNorm(vmin=0., vcenter=1., vmax=relative_nb_iterations.max())
# Replace NaN values with zero

pcm = ax.pcolormesh(X, Y, relative_nb_iterations_1, label='PCG: Green + Jacobi', cmap='seismic', norm=divnorm)

ax.text(0.1, 0.8, r'Total phase contrast $\kappa=10^1$', transform=ax.transAxes)
ax.set_title('Relative number of iteration \n Jacobi-Green / Green ')
# ax.set_zlim(1 ,100)
ax.set_ylabel(r'\# data/geometry sampling points (x direction)')

ax.yaxis.set_label_position('right')
ax.yaxis.tick_right()
ax.set_xlabel(r'\# of nodal points (x direction)')
ax.set_xticks(Nx)
ax.set_xticklabels([f'$2^{i}$' for i in Nx])
ax.set_yticks(Nx)
ax.set_yticklabels([f'$2^{i}$' for i in Nx])
# ax.set_zlabel('# CG iterations')
# Adding a color bar with custom ticks and labels
cbar_ax = fig.add_subplot(gs1[0, 0])

cbar = plt.colorbar(pcm, location='left', cax=cbar_ax)  # Specify the ticks
cbar.ax.invert_yaxis()
# cbar.set_ticks(ticks=[  0, 1,10])
cbar.set_ticks([0, 0.2, 0.5, 1, 2, 5, relative_nb_iterations.max()])
cbar.ax.set_yticklabels(
    ['Jacobi-Green \n is better', '5 times', '2 times', 'Equal', '2 times', '5 times', 'Green \n is better'])
#
counter = 0
for kk in np.arange(np.size(nb_pix_multips)):
    nb_pix_multip = nb_pix_multips[kk]
    print(f'kk = {kk}')
    print(f'nb_pix_multip = {nb_pix_multip}')
    # system set up
    number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

    my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                      problem_type=problem_type)

    discretization = domain.Discretization(cell=my_cell,
                                           nb_of_pixels_global=number_of_pixels,
                                           discretization_type=discretization_type,
                                           element_type=element_type)

    # if kk == 0:
    phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                      microstructure_name=geometry_ID,
                                                      coordinates=discretization.fft.coords,
                                                      seed=1)
    phase_field += 1 / 10 ** ratio
    phase_field = scale_field(phase_field, min_val=1 / 10 ** ratio, max_val=1.0)
    # phase_fied_small_grid=np.copy(phase_field_smooth)
    phase_field = np.copy(phase_field)
    # if kk > 0:
    #     # phase_field_smooth = sc.ndimage.zoom(phase_fied_small_grid, zoom=nb_pix_multip, order=0)
    #     phase_field_smooth = np.repeat(phase_fied_small_grid, 2 ** (kk), axis=0)
    #     phase_field_smooth = np.repeat(phase_field_smooth, 2 ** (kk), axis=1)

    # print(phase_field)

    x = np.arange(0, 1 * number_of_pixels[0])
    y = np.arange(0, 1 * number_of_pixels[1])
    X_, Y_ = np.meshgrid(x, y)

    print(f'kk = {kk}')

    ax0 = fig.add_subplot(gs2[2 - kk, 0])
    ax0.pcolormesh(X_, Y_, np.transpose(phase_field),
                   cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                   rasterized=True)
    ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
               linestyle=linestyles[counter], linewidth=1.)
    # ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
    extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
    extended_y = np.append(phase_field[:, phase_field.shape[0] // 2],
                           phase_field[:, phase_field.shape[0] // 2][-1])

    ax0.set_xticks([])
    ax0.set_yticks([])
    ax0.set_aspect('equal')
    if kk == 2:
        ax0.set_title(r'Geometries')
    ax1 = fig.add_subplot(gs2[2 - kk, 1])
    ax1.step(extended_x, extended_y
             , where='post',
             linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
             label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    ax1.set_ylim([0.05, 1.1])
    ax1.set_xlim([0, 1])
    ax1.set_xticks([])
    ax1.set_xticklabels([])

    ax1.set_yticks([0.1, 0.25, 0.50, 0.75, 1.0001])
    ax1.set_yticklabels([0.1, 0.25, 0.50, 0.75, 1.00])
    ax1.yaxis.set_label_position('right')
    ax1.yaxis.tick_right()
    ax1.set_xticks([])
    ax1.set_xticklabels([])

    ax1.set_aspect('equal')
    if kk == 0:
        ax1.set_xlabel('x coordinate')
    if kk == 2:
        ax1.set_ylabel(f'Phase' + r' $\rho$' f' \n  (linear scale)')
        ax1.set_title(f'Cross sections')

    # log scale plot
    # ax2.step(extended_x, extended_y
    #          , where='post',
    #          linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
    #          label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    # ax2.set_ylim([0.05, 1.1])
    # ax2.set_xlim([0, 1])
    #
    # ax2.set_yticks([0.1, 0.25, 0.50, 0.75, 1.0001])
    # ax2.set_yticklabels([0.1, 0.25, 0.50, 0.75, 1.00])
    # ax2.set_yscale('log')
    # ax2.set_xlabel('x coordinate')
    # ax2.set_ylabel(f'phase' + r' $\rho$' f' \n  (log scale)')
    #
    counter += 1
fname = src + 'JG_exp4_GRID_DEP_geometry_rho1{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')

plt.show()
quit()
### plot geometry
nb_pix_multips = [2, 4, 9]

# material distribution
geometry_ID = 'sine_wave_'

ratio = np.arange(1, 2)

fig = plt.figure()
gs = fig.add_gridspec(3, 3)

ax1 = fig.add_subplot(gs[1, :])
ax2 = fig.add_subplot(gs[2, :])
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']
counter = 0
for kk in np.arange(np.size(nb_pix_multips)):
    nb_pix_multip = nb_pix_multips[kk]
    print(f'kk = {kk}')
    print(f'nb_pix_multip = {nb_pix_multip}')
    # system set up
    number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

    my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                      problem_type=problem_type)

    discretization = domain.Discretization(cell=my_cell,
                                           nb_of_pixels_global=number_of_pixels,
                                           discretization_type=discretization_type,
                                           element_type=element_type)

    # if kk == 0:
    phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                      microstructure_name=geometry_ID,
                                                      coordinates=discretization.fft.coords,
                                                      seed=1)
    phase_field += 1 / 10 ** ratio
    phase_field = scale_field(phase_field, min_val=1 / 10 ** ratio, max_val=1.0)
    # phase_fied_small_grid=np.copy(phase_field_smooth)
    phase_field = np.copy(phase_field)
    # if kk > 0:
    #     # phase_field_smooth = sc.ndimage.zoom(phase_fied_small_grid, zoom=nb_pix_multip, order=0)
    #     phase_field_smooth = np.repeat(phase_fied_small_grid, 2 ** (kk), axis=0)
    #     phase_field_smooth = np.repeat(phase_field_smooth, 2 ** (kk), axis=1)

    # print(phase_field)

    x = np.arange(0, 1 * number_of_pixels[0])
    y = np.arange(0, 1 * number_of_pixels[1])
    X, Y = np.meshgrid(x, y)

    print(f'kk = {kk}')
    ax0 = fig.add_subplot(gs[0, kk])
    ax0.pcolormesh(X, Y, np.transpose(phase_field),
                   cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                   rasterized=True)
    ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
               linestyle=linestyles[counter], linewidth=1.)
    ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
    extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
    extended_y = np.append(phase_field[:, phase_field.shape[0] // 2],
                           phase_field[:, phase_field.shape[0] // 2][-1])

    ax0.set_xticks([])
    ax0.set_yticks([])
    if kk == 0:
        ax0.set_ylabel(r'Geometries')

    ax1.step(extended_x, extended_y
             , where='post',
             linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
             label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    ax1.set_ylim([0.05, 1.1])
    ax1.set_xlim([0, 1])
    ax1.set_xticks([])
    ax1.set_xticklabels([])

    ax1.set_yticks([0.1, 0.25, 0.50, 0.75, 1.0001])
    ax1.set_yticklabels([0.1, 0.25, 0.50, 0.75, 1.00])
    ax1.set_ylabel(f'phase' + r' $\rho$' f' \n  (linear scale)')
    ax1.set_title(f'Cross sections')
    # log scale plot
    ax2.step(extended_x, extended_y
             , where='post',
             linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
             label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    ax2.set_ylim([0.05, 1.1])
    ax2.set_xlim([0, 1])

    ax2.set_yticks([0.1, 0.25, 0.50, 0.75, 1.0001])
    ax2.set_yticklabels([0.1, 0.25, 0.50, 0.75, 1.00])
    ax2.set_yscale('log')
    ax2.set_xlabel('x coordinate')
    ax2.set_ylabel(f'phase' + r' $\rho$' f' \n  (log scale)')
    #
    counter += 1
fname = src + 'JG_exp4_GRID_DEP_geometry_rho1{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')

plt.show()

### plot geometry
nb_pix_multips = [2, 4, 9]

# material distribution
geometry_ID = 'sine_wave_'

ratio = np.arange(4, 5)

fig = plt.figure()
gs = fig.add_gridspec(3, 3)

ax1 = fig.add_subplot(gs[1, :])
ax2 = fig.add_subplot(gs[2, :])
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']
counter = 0
for kk in np.arange(np.size(nb_pix_multips)):
    nb_pix_multip = nb_pix_multips[kk]
    print(f'kk = {kk}')
    print(f'nb_pix_multip = {nb_pix_multip}')
    # system set up
    number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

    my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                      problem_type=problem_type)

    discretization = domain.Discretization(cell=my_cell,
                                           nb_of_pixels_global=number_of_pixels,
                                           discretization_type=discretization_type,
                                           element_type=element_type)

    # if kk == 0:
    phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                      microstructure_name=geometry_ID,
                                                      coordinates=discretization.fft.coords,
                                                      seed=1)
    phase_field += 1 / 10 ** ratio
    phase_field = scale_field(phase_field, min_val=1 / 10 ** ratio, max_val=1.0)
    # phase_fied_small_grid=np.copy(phase_field_smooth)
    phase_field = np.copy(phase_field)
    # if kk > 0:
    #     # phase_field_smooth = sc.ndimage.zoom(phase_fied_small_grid, zoom=nb_pix_multip, order=0)
    #     phase_field_smooth = np.repeat(phase_fied_small_grid, 2 ** (kk), axis=0)
    #     phase_field_smooth = np.repeat(phase_field_smooth, 2 ** (kk), axis=1)

    # print(phase_field)

    x = np.arange(0, 1 * number_of_pixels[0])
    y = np.arange(0, 1 * number_of_pixels[1])
    X, Y = np.meshgrid(x, y)

    print(f'kk = {kk}')
    ax0 = fig.add_subplot(gs[0, kk])
    ax0.pcolormesh(X, Y, np.transpose(phase_field),
                   cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                   rasterized=True)
    ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
               linestyle=linestyles[counter], linewidth=1.)
    ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
    extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
    extended_y = np.append(phase_field[:, phase_field.shape[0] // 2],
                           phase_field[:, phase_field.shape[0] // 2][-1])

    ax0.set_xticks([])
    ax0.set_yticks([])
    if kk == 0:
        ax0.set_ylabel(r'Geometries')

    ax1.step(extended_x, extended_y
             , where='post',
             linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
             label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    ax1.set_ylim([0.0, 1.1])
    ax1.set_xlim([0, 1])
    ax1.set_xticks([])
    ax1.set_xticklabels([])

    ax1.set_yticks([0.0001, 0.25, 0.50, 0.75, 1.0001])
    ax1.set_yticklabels([0.0001, 0.25, 0.50, 0.75, 1.00])
    ax1.set_ylabel(f'phase' + r' $\rho$' f' \n  (linear scale)')
    ax1.set_title(f'Cross sections')
    # log scale plot
    ax2.step(extended_x, extended_y
             , where='post',
             linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
             label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    ax2.set_ylim([0.000009, 1.1])
    ax2.set_xlim([0, 1])

    ax2.set_yticks([0.001, 0.25, 0.50, 0.75, 1.0001])
    ax2.set_yticklabels([0.001, 0.25, 0.50, 0.75, 1.00])

    ax2.set_yscale('log')
    ax2.set_xlabel('x coordinate')
    ax2.set_ylabel(f'phase' + r' $\rho$' f' \n  (log scale)')
    #
    counter += 1
fname = src + 'JG_exp4_GRID_DEP_geometry_rho4{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')
plt.show()

### plot geometry
nb_pix_multips = [2, 4, 9]

# material distribution
geometry_ID = 'sine_wave_'

ratio = np.arange(4, 5)

fig = plt.figure()
gs = fig.add_gridspec(3, 3)

ax1 = fig.add_subplot(gs[1, :])
ax2 = fig.add_subplot(gs[2, :])
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']
counter = 0
for kk in np.arange(np.size(nb_pix_multips)):
    nb_pix_multip = nb_pix_multips[kk]
    print(f'kk = {kk}')
    print(f'nb_pix_multip = {nb_pix_multip}')
    # system set up
    number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

    my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                      problem_type=problem_type)

    discretization = domain.Discretization(cell=my_cell,
                                           nb_of_pixels_global=number_of_pixels,
                                           discretization_type=discretization_type,
                                           element_type=element_type)

    # if kk == 0:
    phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                      microstructure_name=geometry_ID,
                                                      coordinates=discretization.fft.coords,
                                                      seed=1)
    # phase_field += 1 / 10 ** ratio
    phase_field = scale_field(phase_field, min_val=1 / 10 ** ratio, max_val=1.0)
    # phase_fied_small_grid=np.copy(phase_field_smooth)
    phase_field = np.copy(phase_field)
    # if kk > 0:
    #     # phase_field_smooth = sc.ndimage.zoom(phase_fied_small_grid, zoom=nb_pix_multip, order=0)
    #     phase_field_smooth = np.repeat(phase_fied_small_grid, 2 ** (kk), axis=0)
    #     phase_field_smooth = np.repeat(phase_field_smooth, 2 ** (kk), axis=1)

    # print(phase_field)

    x = np.arange(0, 1 * number_of_pixels[0])
    y = np.arange(0, 1 * number_of_pixels[1])
    X, Y = np.meshgrid(x, y)

    print(f'kk = {kk}')
    ax0 = fig.add_subplot(gs[0, kk])
    ax0.pcolormesh(X, Y, np.transpose(phase_field),
                   cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                   rasterized=True)
    ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
               linestyle=linestyles[counter], linewidth=1.)
    ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
    extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
    extended_y = np.append(phase_field[:, phase_field.shape[0] // 2],
                           phase_field[:, phase_field.shape[0] // 2][-1])

    ax0.set_xticks([])
    ax0.set_yticks([])
    if kk == 0:
        ax0.set_ylabel(r'Geometries')

    ax1.step(extended_x, extended_y
             , where='post',
             linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
             label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    ax1.set_ylim([0.0, 1.1])
    ax1.set_xlim([0, 1])
    ax1.set_xticks([])
    ax1.set_xticklabels([])

    ax1.set_yticks([0.00, 0.25, 0.50, 0.75, 1.0001])
    ax1.set_yticklabels([0.0, 0.25, 0.50, 0.75, 1.00])
    ax1.set_ylabel(f'phase' + r' $\rho$' f' \n  (linear scale)')
    ax1.set_title(f'Cross sections')
    # log scale plot
    ax2.step(extended_x, extended_y
             , where='post',
             linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
             label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    # ax2.set_ylim([0.0, 1.1])
    ax2.set_xlim([0, 1])
    #
    ax2.set_yticks([0.0, 0.25, 0.50, 0.75, 1.0001])
    ax2.set_yticklabels([0.0, 0.25, 0.50, 0.75, 1.00])

    ax2.set_yscale('log')
    ax2.set_xlabel('x coordinate')
    ax2.set_ylabel(f'phase' + r' $\rho$' f' \n  (semilog scale)')
    #
    counter += 1
fname = src + 'JG_exp4_GRID_DEP_geometry_rho4_inf{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')
plt.show()

### plot geometry
nb_pix_multips = [2, 4, 9]

# material distribution
geometry_ID = 'sine_wave_inv'

ratio = np.arange(4, 5)

fig = plt.figure()
gs = fig.add_gridspec(3, 3)

ax1 = fig.add_subplot(gs[1, :])
ax2 = fig.add_subplot(gs[2, :])
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']
counter = 0
for kk in np.arange(np.size(nb_pix_multips)):
    nb_pix_multip = nb_pix_multips[kk]
    print(f'kk = {kk}')
    print(f'nb_pix_multip = {nb_pix_multip}')
    # system set up
    number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

    my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                      problem_type=problem_type)

    discretization = domain.Discretization(cell=my_cell,
                                           nb_of_pixels_global=number_of_pixels,
                                           discretization_type=discretization_type,
                                           element_type=element_type)

    # if kk == 0:
    phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                      microstructure_name=geometry_ID,
                                                      coordinates=discretization.fft.coords,
                                                      seed=1)
    # phase_field += 1 / 10 ** ratio
    phase_field = scale_field(phase_field, min_val=1 / 10 ** ratio, max_val=1.0)
    # phase_fied_small_grid=np.copy(phase_field_smooth)
    phase_field = np.copy(phase_field)
    # if kk > 0:
    #     # phase_field_smooth = sc.ndimage.zoom(phase_fied_small_grid, zoom=nb_pix_multip, order=0)
    #     phase_field_smooth = np.repeat(phase_fied_small_grid, 2 ** (kk), axis=0)
    #     phase_field_smooth = np.repeat(phase_field_smooth, 2 ** (kk), axis=1)

    # print(phase_field)

    x = np.arange(0, 1 * number_of_pixels[0])
    y = np.arange(0, 1 * number_of_pixels[1])
    X, Y = np.meshgrid(x, y)

    print(f'kk = {kk}')
    ax0 = fig.add_subplot(gs[0, kk])
    ax0.pcolormesh(X, Y, np.transpose(phase_field),
                   cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                   rasterized=True)
    ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
               linestyle=linestyles[counter], linewidth=1.)
    ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
    extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
    extended_y = np.append(phase_field[:, phase_field.shape[0] // 2],
                           phase_field[:, phase_field.shape[0] // 2][-1])

    ax0.set_xticks([])
    ax0.set_yticks([])
    if kk == 0:
        ax0.set_ylabel(r'Geometries')

    ax1.step(extended_x, extended_y
             , where='post',
             linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
             label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    ax1.set_ylim([0.0, 1.1])
    ax1.set_xlim([0, 1])
    ax1.set_xticks([])
    ax1.set_xticklabels([])

    ax1.set_yticks([0.00, 0.25, 0.50, 0.75, 1.0001])
    ax1.set_yticklabels([0.0, 0.25, 0.50, 0.75, 1.00])
    ax1.set_ylabel(f'phase' + r' $\rho$' f' \n  (linear scale)')
    ax1.set_title(f'Cross sections')
    # log scale plot
    ax2.step(extended_x, extended_y
             , where='post',
             linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
             label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    # ax2.set_ylim([0.0, 1.1])
    ax2.set_xlim([0, 1])
    #
    ax2.set_yticks([0.0, 0.25, 0.50, 0.75, 1.0001])
    ax2.set_yticklabels([0.0, 0.25, 0.50, 0.75, 1.00])

    ax2.set_yscale('log')
    ax2.set_xlabel('x coordinate')
    ax2.set_ylabel(f'phase' + r' $\rho$' f' \n  (semilog scale)')
    #
    counter += 1
fname = src + 'JG_exp4_GRID_DEP_geometry_rho4_inf_inv{}'.format('.pdf')
print(('create figure: {}'.format(fname)))
plt.savefig(fname, bbox_inches='tight')
plt.show()

### plot geometry
nb_pix_multips = [2, 5, 9]

# material distribution
geometry_ID = 'sine_wave_inv'

ratio = np.arange(4, 5)

fig = plt.figure()
gs = fig.add_gridspec(2, 3)

ax1 = fig.add_subplot(gs[1, :])
linestyles = ['-', '--', ':']
colors = ['red', 'blue', 'green', 'orange', 'purple']
counter = 0
for kk in np.arange(np.size(nb_pix_multips)):
    nb_pix_multip = nb_pix_multips[kk]
    print(f'kk = {kk}')
    print(f'nb_pix_multip = {nb_pix_multip}')
    # system set up
    number_of_pixels = (2 ** nb_pix_multip, 2 ** nb_pix_multip)

    my_cell = domain.PeriodicUnitCell(domain_size=domain_size,
                                      problem_type=problem_type)

    discretization = domain.Discretization(cell=my_cell,
                                           nb_of_pixels_global=number_of_pixels,
                                           discretization_type=discretization_type,
                                           element_type=element_type)

    # if kk == 0:
    phase_field = microstructure_library.get_geometry(nb_voxels=discretization.nb_of_pixels,
                                                      microstructure_name=geometry_ID,
                                                      coordinates=discretization.fft.coords,
                                                      seed=1)
    # phase_field += 1 / 10 ** ratio
    # phase_fied_small_grid=np.copy(phase_field_smooth)
    phase_field = np.copy(phase_field)
    # if kk > 0:
    #     # phase_field_smooth = sc.ndimage.zoom(phase_fied_small_grid, zoom=nb_pix_multip, order=0)
    #     phase_field_smooth = np.repeat(phase_fied_small_grid, 2 ** (kk), axis=0)
    #     phase_field_smooth = np.repeat(phase_field_smooth, 2 ** (kk), axis=1)

    # print(phase_field)

    x = np.arange(0, 1 * number_of_pixels[0])
    y = np.arange(0, 1 * number_of_pixels[1])
    X, Y = np.meshgrid(x, y)

    print(f'kk = {kk}')
    ax0 = fig.add_subplot(gs[0, kk])
    ax0.pcolormesh(X, Y, np.transpose(phase_field),
                   cmap=mpl.cm.Greys, vmin=1e-4, vmax=1, linewidth=0,
                   rasterized=True)
    ax0.hlines(y=number_of_pixels[1] // 2, xmin=-0.5, xmax=number_of_pixels[0] - 0.5, color=colors[counter],
               linestyle=linestyles[counter], linewidth=1.)
    ax0.set_title(f'Resolution $(2^{nb_pix_multip})^{2}$')
    #
    # ax0.set_xticks(np.arange(-.5, number_of_pixels[0], int(number_of_pixels[0] / 4)))
    # ax0.set_yticks(np.arange(-.5, number_of_pixels[1], int(number_of_pixels[1] / 4)))
    # ax0.set_xticklabels(np.arange(0, number_of_pixels[0] + 1, int(number_of_pixels[0] / 4)))
    # ax0.set_yticklabels(np.arange(0, number_of_pixels[1] + 1, int(number_of_pixels[1] / 4)))
    extended_x = np.linspace(0, 1, phase_field[:, phase_field.shape[0] // 2].size + 1)
    extended_y = np.append(phase_field[:, phase_field.shape[0] // 2],
                           phase_field[:, phase_field.shape[0] // 2][-1])
    ax1.step(extended_x, extended_y
             , where='post',
             linewidth=1, color=colors[counter], linestyle=linestyles[counter],  # marker='|',
             label=r'phase contrast -' + f'1e{nb_pix_multips[kk]} ')
    # ax3.plot(phase_field[:, phase_field.shape[0] // 2], linewidth=1)
    ax1.set_ylim([0.000009, 1.1])
    ax1.set_xlim([0, 1])
    ax1.set_yticks([0.001, 0.25, 0.50, 0.75, 1.0001])
    ax1.set_yticklabels([0.001, 0.25, 0.50, 0.75, 1.00])
    ax1.set_yscale('log')
    counter += 1
plt.show()
#
# io= 1
# greeen
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 7.  9.  0.  0.  0.  0.  0.  0.]
#  [ 9. 10. 11.  0.  0.  0.  0.  0.]
#  [ 9. 10. 11. 11.  0.  0.  0.  0.]
#  [10. 10. 10. 10. 10.  0.  0.  0.]
#  [10. 10.  9. 10.  9.  8.  0.  0.]
#  [10.  9.  9.  9.  8.  8.  7.  0.]
#  [10.  9.  9.  8.  8.  7.  7.  6.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 10.   8.   0.   0.   0.   0.   0.   0.]
#  [ 18.  15.  14.   0.   0.   0.   0.   0.]
#  [ 29.  24.  21.  18.   0.   0.   0.   0.]
#  [ 54.  45.  40.  36.  30.   0.   0.   0.]
#  [104.  85.  78.  70.  60.  50.   0.   0.]
#  [201. 154. 144. 134. 119.  97.  92.   0.]
#  [352. 299. 265. 243. 211. 176. 156. 156.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 5.  4.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  4.  0.  0.  0.  0.  0.]
#  [ 7.  6.  5.  3.  0.  0.  0.  0.]
#  [ 9.  6.  5.  5.  3.  0.  0.  0.]
#  [11.  7.  6.  5.  4.  3.  0.  0.]
#  [15. 10.  7.  6.  5.  4.  3.  0.]
#  [24. 13.  9.  7.  6.  5.  3.  3.]]
# ratio= 2
# greeen
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8. 10.  0.  0.  0.  0.  0.  0.]
#  [10. 14. 18.  0.  0.  0.  0.  0.]
#  [11. 16. 23. 24.  0.  0.  0.  0.]
#  [12. 16. 23. 25. 26.  0.  0.  0.]
#  [17. 16. 23. 24. 24. 23.  0.  0.]
#  [17. 16. 23. 22. 22. 21. 19.  0.]
#  [17. 16. 21. 21. 20. 19. 17. 15.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 20.  17.  15.   0.   0.   0.   0.   0.]
#  [ 32.  24.  24.  23.   0.   0.   0.   0.]
#  [ 61.  47.  46.  45.  43.   0.   0.   0.]
#  [115.  89.  86.  87.  83.  81.   0.   0.]
#  [216. 166. 166. 160. 159. 150. 145.   0.]
#  [418. 312. 308. 305. 295. 288. 269. 265.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 8.  6.  4.  0.  0.  0.  0.  0.]
#  [10.  7.  5.  4.  0.  0.  0.  0.]
#  [12. 10.  7.  5.  3.  0.  0.  0.]
#  [20. 13.  9.  6.  5.  3.  0.  0.]
#  [34. 21. 11.  8.  6.  4.  3.  0.]
#  [60. 34. 18. 10.  8.  6.  4.  3.]]
# ratio= 3
# greeen
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8. 11.  0.  0.  0.  0.  0.  0.]
#  [10. 16. 20.  0.  0.  0.  0.  0.]
#  [11. 17. 27. 33.  0.  0.  0.  0.]
#  [11. 17. 30. 43. 48.  0.  0.  0.]
#  [11. 17. 30. 43. 51. 54.  0.  0.]
#  [11. 17. 29. 42. 49. 49. 45.  0.]
#  [11. 19. 28. 42. 43. 42. 38. 32.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 20.  17.  16.   0.   0.   0.   0.   0.]
#  [ 32.  25.  25.  24.   0.   0.   0.   0.]
#  [ 61.  47.  47.  46.  46.   0.   0.   0.]
#  [117.  89.  86.  89.  87.  87.   0.   0.]
#  [219. 170. 166. 165. 165. 163. 162.   0.]
#  [423. 315. 310. 313. 310. 309. 301. 300.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 8.  6.  5.  0.  0.  0.  0.  0.]
#  [10.  8.  5.  4.  0.  0.  0.  0.]
#  [14. 10.  8.  5.  3.  0.  0.  0.]
#  [22. 18. 11.  8.  5.  3.  0.  0.]
#  [42. 29. 19. 10.  7.  4.  3.  0.]
#  [77. 49. 27. 17. 10.  7.  4.  3.]]
# ratio= 4
# greeen
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8. 11.  0.  0.  0.  0.  0.  0.]
#  [10. 16. 20.  0.  0.  0.  0.  0.]
#  [11. 18. 27. 35.  0.  0.  0.  0.]
#  [11. 17. 32. 47. 53.  0.  0.  0.]
#  [11. 17. 31. 48. 73. 87.  0.  0.]
#  [11. 19. 30. 49. 69. 85. 84.  0.]
#  [11. 19. 29. 48. 65. 79. 66. 52.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 20.  17.  16.   0.   0.   0.   0.   0.]
#  [ 32.  25.  25.  24.   0.   0.   0.   0.]
#  [ 62.  47.  47.  46.  46.   0.   0.   0.]
#  [117.  89.  86.  89.  88.  88.   0.   0.]
#  [220. 171. 167. 165. 166. 165. 166.   0.]
#  [423. 318. 310. 313. 312. 312. 308. 310.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 8.  6.  5.  0.  0.  0.  0.  0.]
#  [10.  9.  5.  4.  0.  0.  0.  0.]
#  [15. 11.  8.  5.  3.  0.  0.  0.]
#  [24. 19. 12.  8.  5.  3.  0.  0.]
#  [45. 32. 20. 13.  8.  4.  3.  0.]
#  [82. 56. 35. 20. 11.  8.  4.  3.]]


# 00000000
# ratio= 1
# greeen
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8.  9.  0.  0.  0.  0.  0.  0.]
#  [10. 13. 14.  0.  0.  0.  0.  0.]
#  [11. 15. 17. 16.  0.  0.  0.  0.]
#  [11. 15. 18. 18. 14.  0.  0.  0.]
#  [11. 15. 18. 18. 17. 12.  0.  0.]
#  [11. 15. 17. 18. 17. 15. 11.  0.]
#  [11. 15. 17. 17. 17. 14. 12.  9.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 21.  18.  16.   0.   0.   0.   0.   0.]
#  [ 33.  28.  26.  24.   0.   0.   0.   0.]
#  [ 62.  51.  48.  46.  44.   0.   0.   0.]
#  [120.  96.  91.  87.  84.  80.   0.   0.]
#  [222. 180. 176. 165. 157. 152. 145.   0.]
#  [427. 351. 337. 315. 297. 279. 267. 250.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 7.  6.  5.  0.  0.  0.  0.  0.]
#  [ 8.  7.  6.  5.  0.  0.  0.  0.]
#  [ 9.  8.  7.  6.  4.  0.  0.  0.]
#  [12. 10.  8.  6.  5.  4.  0.  0.]
#  [15. 14. 11.  8.  6.  4.  4.  0.]
#  [23. 20. 15. 11.  7.  6.  4.  3.]]
# ratio= 2
# greeen
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8. 10.  0.  0.  0.  0.  0.  0.]
#  [10. 15. 19.  0.  0.  0.  0.  0.]
#  [11. 17. 25. 30.  0.  0.  0.  0.]
#  [11. 17. 28. 36. 35.  0.  0.  0.]
#  [11. 17. 28. 36. 43. 33.  0.  0.]
#  [11. 18. 27. 37. 42. 37. 24.  0.]
#  [11. 19. 27. 36. 42. 35. 24. 16.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 20.  17.  16.   0.   0.   0.   0.   0.]
#  [ 32.  25.  25.  24.   0.   0.   0.   0.]
#  [ 61.  47.  47.  47.  46.   0.   0.   0.]
#  [117.  89.  89.  89.  88.  87.   0.   0.]
#  [219. 172. 166. 165. 165. 164. 162.   0.]
#  [423. 326. 313. 314. 312. 309. 304. 300.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 7.  6.  5.  0.  0.  0.  0.  0.]
#  [ 8.  7.  5.  4.  0.  0.  0.  0.]
#  [ 9.  8.  7.  5.  4.  0.  0.  0.]
#  [12. 11.  9.  7.  5.  3.  0.  0.]
#  [15. 16. 11. 10.  7.  4.  3.  0.]
#  [24. 22. 19. 15.  8.  7.  4.  3.]]
# ratio= 3
# greeen
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8. 11.  0.  0.  0.  0.  0.  0.]
#  [10. 16. 20.  0.  0.  0.  0.  0.]
#  [11. 18. 27. 34.  0.  0.  0.  0.]
#  [11. 17. 31. 45. 51.  0.  0.  0.]
#  [11. 17. 30. 46. 68. 71.  0.  0.]
#  [11. 19. 30. 48. 65. 76. 60.  0.]
#  [11. 19. 29. 46. 64. 71. 44. 32.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 20.  17.  16.   0.   0.   0.   0.   0.]
#  [ 32.  25.  25.  24.   0.   0.   0.   0.]
#  [ 62.  47.  47.  46.  46.   0.   0.   0.]
#  [117.  89.  86.  89.  89.  89.   0.   0.]
#  [220. 171. 166. 165. 166. 166. 166.   0.]
#  [423. 318. 311. 313. 313. 312. 311. 310.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 7.  6.  5.  0.  0.  0.  0.  0.]
#  [ 8.  7.  5.  4.  0.  0.  0.  0.]
#  [ 9.  8.  7.  5.  3.  0.  0.  0.]
#  [12. 11.  9.  8.  5.  3.  0.  0.]
#  [15. 16. 14. 10.  7.  4.  3.  0.]
#  [23. 24. 20. 16. 12.  7.  4.  3.]]
# ratio= 4
# greeen
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [  8.  11.   0.   0.   0.   0.   0.   0.]
#  [ 10.  16.  20.   0.   0.   0.   0.   0.]
#  [ 11.  18.  27.  35.   0.   0.   0.   0.]
#  [ 11.  17.  32.  47.  54.   0.   0.   0.]
#  [ 11.  17.  31.  48.  76.  89.   0.   0.]
#  [ 11.  19.  30.  49.  72.  97. 100.   0.]
#  [ 11.  19.  29.  49.  68.  88.  73.  53.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 20.  17.  16.   0.   0.   0.   0.   0.]
#  [ 32.  25.  25.  24.   0.   0.   0.   0.]
#  [ 62.  47.  47.  46.  46.   0.   0.   0.]
#  [117.  89.  86.  89.  88.  89.   0.   0.]
#  [220. 171. 167. 165. 166. 165. 167.   0.]
#  [423. 318. 310. 313. 311. 312. 310. 312.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 7.  6.  5.  0.  0.  0.  0.  0.]
#  [ 8.  7.  5.  4.  0.  0.  0.  0.]
#  [ 9.  8.  7.  5.  3.  0.  0.  0.]
#  [12. 11.  9.  8.  5.  3.  0.  0.]
#  [16. 16. 14. 10.  8.  4.  3.  0.]
#  [24. 24. 20. 16. 10.  8.  4.  3.]]


# naopak
# ratio= 1
# #greeen
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8.  9.  0.  0.  0.  0.  0.  0.]
#  [10. 13. 14.  0.  0.  0.  0.  0.]
#  [11. 15. 17. 16.  0.  0.  0.  0.]
#  [11. 15. 18. 18. 14.  0.  0.  0.]
#  [11. 15. 18. 18. 17. 12.  0.  0.]
#  [11. 15. 17. 18. 17. 15. 11.  0.]
#  [11. 15. 17. 17. 17. 14. 12.  9.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 21.  18.  16.   0.   0.   0.   0.   0.]
#  [ 33.  28.  26.  24.   0.   0.   0.   0.]
#  [ 62.  51.  48.  46.  44.   0.   0.   0.]
#  [120.  96.  91.  87.  84.  80.   0.   0.]
#  [222. 180. 176. 165. 157. 152. 145.   0.]
#  [427. 351. 337. 315. 297. 279. 267. 250.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 7.  6.  5.  0.  0.  0.  0.  0.]
#  [ 8.  7.  6.  5.  0.  0.  0.  0.]
#  [ 9.  8.  7.  6.  4.  0.  0.  0.]
#  [12. 10.  8.  6.  5.  4.  0.  0.]
#  [16. 14. 11.  8.  6.  4.  4.  0.]
#  [24. 20. 16. 10.  7.  6.  4.  3.]]
# ratio= 2
# greeen
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8. 10.  0.  0.  0.  0.  0.  0.]
#  [10. 15. 19.  0.  0.  0.  0.  0.]
#  [11. 17. 25. 30.  0.  0.  0.  0.]
#  [11. 17. 28. 36. 35.  0.  0.  0.]
#  [11. 17. 28. 36. 43. 33.  0.  0.]
#  [11. 18. 27. 37. 42. 37. 24.  0.]
#  [11. 19. 27. 36. 42. 35. 24. 16.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 20.  17.  16.   0.   0.   0.   0.   0.]
#  [ 32.  25.  25.  24.   0.   0.   0.   0.]
#  [ 61.  47.  47.  47.  46.   0.   0.   0.]
#  [117.  89.  89.  89.  88.  87.   0.   0.]
#  [219. 172. 166. 165. 165. 164. 162.   0.]
#  [423. 326. 313. 314. 312. 309. 304. 300.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 7.  6.  5.  0.  0.  0.  0.  0.]
#  [ 8.  7.  5.  4.  0.  0.  0.  0.]
#  [ 9.  8.  7.  5.  4.  0.  0.  0.]
#  [12. 10.  9.  7.  5.  3.  0.  0.]
#  [16. 15. 11.  9.  7.  4.  3.  0.]
#  [23. 22. 18. 15.  9.  7.  4.  3.]]
# ratio= 3
# greeen
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8. 11.  0.  0.  0.  0.  0.  0.]
#  [10. 16. 20.  0.  0.  0.  0.  0.]
#  [11. 18. 27. 34.  0.  0.  0.  0.]
#  [11. 17. 31. 45. 51.  0.  0.  0.]
#  [11. 17. 30. 46. 68. 71.  0.  0.]
#  [11. 19. 30. 48. 65. 76. 60.  0.]
#  [11. 19. 29. 46. 64. 71. 44. 32.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 20.  17.  16.   0.   0.   0.   0.   0.]
#  [ 32.  25.  25.  24.   0.   0.   0.   0.]
#  [ 62.  47.  47.  46.  46.   0.   0.   0.]
#  [117.  89.  86.  89.  89.  89.   0.   0.]
#  [220. 171. 166. 165. 166. 166. 166.   0.]
#  [423. 318. 311. 313. 313. 312. 311. 310.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 7.  6.  5.  0.  0.  0.  0.  0.]
#  [ 8.  7.  5.  4.  0.  0.  0.  0.]
#  [ 9.  8.  7.  5.  3.  0.  0.  0.]
#  [11. 11.  9.  8.  5.  3.  0.  0.]
#  [14. 16. 14. 10.  7.  4.  3.  0.]
#  [22. 23. 20. 16. 12.  7.  4.  3.]]
# ratio= 4
# greeen
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [  8.  11.   0.   0.   0.   0.   0.   0.]
#  [ 10.  16.  20.   0.   0.   0.   0.   0.]
#  [ 11.  18.  27.  35.   0.   0.   0.   0.]
#  [ 11.  17.  32.  47.  54.   0.   0.   0.]
#  [ 11.  17.  31.  48.  76.  89.   0.   0.]
#  [ 11.  19.  30.  49.  72.  97. 100.   0.]
#  [ 11.  19.  29.  49.  68.  88.  73.  53.]]
# jacobi
# [[  5.   0.   0.   0.   0.   0.   0.   0.]
#  [ 11.  10.   0.   0.   0.   0.   0.   0.]
#  [ 20.  17.  16.   0.   0.   0.   0.   0.]
#  [ 32.  25.  25.  24.   0.   0.   0.   0.]
#  [ 62.  47.  47.  46.  46.   0.   0.   0.]
#  [117.  89.  86.  89.  88.  89.   0.   0.]
#  [220. 171. 167. 165. 166. 165. 167.   0.]
#  [423. 318. 310. 313. 311. 312. 310. 312.]]
# combi
# [[ 5.  0.  0.  0.  0.  0.  0.  0.]
#  [ 6.  5.  0.  0.  0.  0.  0.  0.]
#  [ 7.  6.  5.  0.  0.  0.  0.  0.]
#  [ 8.  7.  5.  4.  0.  0.  0.  0.]
#  [ 9.  8.  7.  5.  3.  0.  0.  0.]
#  [11. 11.  9.  8.  5.  3.  0.  0.]
#  [14. 16. 14. 10.  8.  4.  3.  0.]
#  [22. 24. 20. 16. 10.  8.  4.  3.]]


#################################### 3.Marz 2025
# ratios = [1 2 3 4]
# nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10]
# ratio= 1
# greeen
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 4.  8.  0.  0.  0.  0.  0.  0.  0.]
#  [ 4.  8. 17.  0.  0.  0.  0.  0.  0.]
#  [ 4.  8. 17. 27.  0.  0.  0.  0.  0.]
#  [ 4.  8. 17. 29. 34.  0.  0.  0.  0.]
#  [ 4.  8. 18. 28. 34. 37.  0.  0.  0.]
#  [ 4.  9. 18. 28. 34. 37. 38.  0.  0.]
#  [ 4.  9. 18. 28. 34. 37. 38. 38.  0.]
#  [ 5.  9. 19. 29. 34. 37. 38. 38. 38.]]
# combi
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8.  7.  0.  0.  0.  0.  0.  0.  0.]
#  [ 9. 11.  8.  0.  0.  0.  0.  0.  0.]
#  [ 9. 14. 10.  8.  0.  0.  0.  0.  0.]
#  [10. 17. 14. 10.  9.  0.  0.  0.  0.]
#  [10. 18. 17. 14. 10. 10.  0.  0.  0.]
#  [11. 20. 20. 18. 14. 10. 10.  0.  0.]
#  [12. 20. 23. 20. 18. 16. 10. 10.  0.]
#  [15. 23. 30. 25. 21. 19. 16. 11. 11.]]
# left_cluster_x3
# ratio= 2
# greeen
# [[  4.   0.   0.   0.   0.   0.   0.   0.   0.]
#  [  4.   8.   0.   0.   0.   0.   0.   0.   0.]
#  [  4.   8.  19.   0.   0.   0.   0.   0.   0.]
#  [  4.   9.  21.  43.   0.   0.   0.   0.   0.]
#  [  4.   9.  21.  47.  77.   0.   0.   0.   0.]
#  [  4.  10.  22.  48.  83. 103.   0.   0.   0.]
#  [  4.  10.  23.  49.  83. 106. 112.   0.   0.]
#  [  4.  11.  23.  50.  87. 106. 113. 115.   0.]
#  [  5.  11.  24.  50.  85. 107. 114. 116. 117.]]
# combi
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8.  8.  0.  0.  0.  0.  0.  0.  0.]
#  [ 9. 14.  9.  0.  0.  0.  0.  0.  0.]
#  [ 9. 17. 13.  9.  0.  0.  0.  0.  0.]
#  [10. 18. 17. 12. 10.  0.  0.  0.  0.]
#  [11. 20. 22. 17. 11. 11.  0.  0.  0.]
#  [13. 21. 27. 22. 18. 11. 11.  0.  0.]
#  [15. 24. 34. 27. 23. 18. 11. 11.  0.]
#  [16. 30. 43. 36. 28. 25. 20. 12. 12.]]
# left_cluster_x3
# ratio= 3
# greeen
# [[  4.   0.   0.   0.   0.   0.   0.   0.   0.]
#  [  4.   8.   0.   0.   0.   0.   0.   0.   0.]
#  [  4.   9.  21.   0.   0.   0.   0.   0.   0.]
#  [  4.   9.  22.  48.   0.   0.   0.   0.   0.]
#  [  4.  10.  24.  56. 119.   0.   0.   0.   0.]
#  [  4.  11.  25.  59. 136. 234.   0.   0.   0.]
#  [  4.  11.  26.  60. 138. 250. 313.   0.   0.]
#  [  4.  11.  25.  60. 139. 251. 321. 338.   0.]
#  [  5.  12.  27.  63. 142. 254. 322. 341. 345.]]
# combi
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8.  8.  0.  0.  0.  0.  0.  0.  0.]
#  [ 9. 16.  9.  0.  0.  0.  0.  0.  0.]
#  [ 9. 18. 15. 10.  0.  0.  0.  0.  0.]
#  [10. 19. 20. 14. 11.  0.  0.  0.  0.]
#  [11. 21. 26. 20. 12. 11.  0.  0.  0.]
#  [14. 23. 35. 27. 21. 12. 12.  0.  0.]
#  [15. 27. 43. 34. 26. 22. 13. 13.  0.]
#  [17. 34. 54. 47. 35. 28. 23. 13. 13.]]
# left_cluster_x3
# ratio= 4
# greeen
# [[   4.    0.    0.    0.    0.    0.    0.    0.    0.]
#  [   4.    9.    0.    0.    0.    0.    0.    0.    0.]
#  [   4.    9.   21.    0.    0.    0.    0.    0.    0.]
#  [   4.    9.   23.   51.    0.    0.    0.    0.    0.]
#  [   4.   10.   25.   61.  136.    0.    0.    0.    0.]
#  [   4.   11.   26.   64.  160.  350.    0.    0.    0.]
#  [   4.   11.   27.   67.  164.  390.  684.    0.    0.]
#  [   4.   11.   27.   67.  167.  399.  724.  934.    0.]
#  [   5.   12.   28.   71.  172.  406.  731.  954. 1009.]]
# combi
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8.  8.  0.  0.  0.  0.  0.  0.  0.]
#  [ 9. 16.  9.  0.  0.  0.  0.  0.  0.]
#  [ 9. 18. 16. 11.  0.  0.  0.  0.  0.]
#  [10. 19. 23. 16. 11.  0.  0.  0.  0.]
#  [12. 21. 30. 24. 14. 12.  0.  0.  0.]
#  [14. 23. 37. 32. 24. 14. 12.  0.  0.]
#  [15. 31. 47. 42. 32. 24. 14. 13.  0.]
#  [17. 36. 56. 61. 44. 34. 26. 14. 13.]]
# left_cluster_x3

#
# ratios = [1 2 3 4]
# nb_pix_multips = [2, 3, 4, 5, 6, 7, 8, 9, 10]
# ratio= 1
# greeen
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 4.  8.  0.  0.  0.  0.  0.  0.  0.]
#  [ 4.  8. 16.  0.  0.  0.  0.  0.  0.]
#  [ 4.  8. 16. 24.  0.  0.  0.  0.  0.]
#  [ 4.  8. 16. 24. 27.  0.  0.  0.  0.]
#  [ 4.  8. 16. 24. 27. 28.  0.  0.  0.]
#  [ 4.  8. 16. 24. 27. 28. 28.  0.  0.]
#  [ 4.  8. 16. 24. 27. 28. 28. 28.  0.]
#  [ 4.  8. 16. 24. 27. 28. 28. 28. 28.]]
# combi
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8.  6.  0.  0.  0.  0.  0.  0.  0.]
#  [ 9.  9.  6.  0.  0.  0.  0.  0.  0.]
#  [ 9. 11.  9.  7.  0.  0.  0.  0.  0.]
#  [ 9. 13. 11.  8.  7.  0.  0.  0.  0.]
#  [10. 16. 14. 12.  8.  7.  0.  0.  0.]
#  [10. 19. 16. 14. 12.  8.  8.  0.  0.]
#  [11. 20. 20. 17. 14. 12.  8.  8.  0.]
#  [12. 22. 25. 19. 17. 15. 13.  8.  8.]]
# linear
# ratio= 2
# greeen
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 4.  8.  0.  0.  0.  0.  0.  0.  0.]
#  [ 4.  8. 16.  0.  0.  0.  0.  0.  0.]
#  [ 4.  8. 16. 32.  0.  0.  0.  0.  0.]
#  [ 4.  8. 16. 32. 47.  0.  0.  0.  0.]
#  [ 4.  8. 16. 32. 47. 63.  0.  0.  0.]
#  [ 4.  8. 16. 32. 47. 63. 79.  0.  0.]
#  [ 4.  8. 16. 32. 47. 63. 79. 91.  0.]
#  [ 4.  8. 16. 32. 47. 63. 79. 91. 96.]]
# combi
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8.  7.  0.  0.  0.  0.  0.  0.  0.]
#  [ 9. 12.  8.  0.  0.  0.  0.  0.  0.]
#  [ 9. 15. 13.  8.  0.  0.  0.  0.  0.]
#  [10. 17. 16. 13.  8.  0.  0.  0.  0.]
#  [11. 20. 20. 16. 12. 10.  0.  0.  0.]
#  [11. 21. 23. 20. 18. 12. 10.  0.  0.]
#  [12. 22. 29. 25. 22. 17. 12. 10.  0.]
#  [14. 24. 37. 33. 27. 22. 18. 12. 11.]]
# linear
# ratio= 3
# greeen
# [[  4.   0.   0.   0.   0.   0.   0.   0.   0.]
#  [  4.   8.   0.   0.   0.   0.   0.   0.   0.]
#  [  4.   8.  16.   0.   0.   0.   0.   0.   0.]
#  [  4.   8.  16.  32.   0.   0.   0.   0.   0.]
#  [  4.   8.  16.  32.  52.   0.   0.   0.   0.]
#  [  4.   8.  16.  32.  52.  76.   0.   0.   0.]
#  [  4.   8.  16.  32.  52.  76. 106.   0.   0.]
#  [  4.   8.  16.  32.  52.  76. 106. 146.   0.]
#  [  4.   8.  16.  32.  52.  76. 106. 146. 194.]]
# combi
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8.  7.  0.  0.  0.  0.  0.  0.  0.]
#  [ 9. 13.  8.  0.  0.  0.  0.  0.  0.]
#  [ 9. 16. 14.  9.  0.  0.  0.  0.  0.]
#  [10. 19. 17. 14. 11.  0.  0.  0.  0.]
#  [11. 20. 22. 19. 16. 11.  0.  0.  0.]
#  [12. 22. 27. 24. 21. 16. 11.  0.  0.]
#  [14. 24. 33. 31. 27. 22. 16. 12.  0.]
#  [16. 27. 43. 38. 34. 30. 24. 17. 13.]]
# linear
# ratio= 4
# greeen
# [[  4.   0.   0.   0.   0.   0.   0.   0.   0.]
#  [  4.   8.   0.   0.   0.   0.   0.   0.   0.]
#  [  4.   8.  16.   0.   0.   0.   0.   0.   0.]
#  [  4.   8.  16.  32.   0.   0.   0.   0.   0.]
#  [  4.   8.  16.  32.  54.   0.   0.   0.   0.]
#  [  4.   8.  16.  32.  54.  80.   0.   0.   0.]
#  [  4.   8.  16.  32.  54.  80. 115.   0.   0.]
#  [  4.   8.  16.  32.  54.  80. 115. 163.   0.]
#  [  4.   8.  16.  32.  54.  80. 115. 163. 229.]]
# combi
# [[ 4.  0.  0.  0.  0.  0.  0.  0.  0.]
#  [ 8.  8.  0.  0.  0.  0.  0.  0.  0.]
#  [ 9. 14.  9.  0.  0.  0.  0.  0.  0.]
#  [ 9. 17. 15.  9.  0.  0.  0.  0.  0.]
#  [10. 19. 19. 15. 11.  0.  0.  0.  0.]
#  [11. 20. 23. 20. 17. 12.  0.  0.  0.]
#  [12. 22. 28. 26. 23. 17. 12.  0.  0.]
#  [16. 24. 36. 33. 29. 25. 18. 14.  0.]
#  [17. 29. 44. 42. 37. 32. 27. 19. 14.]]
# linear
